Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    EQUAL
    FOR
    FUNCTION
    GREATER_EQUAL
    GREATER_THAN
    LESS_EQUAL
    LESS_THAN
    NOT_EQUALS
    PROCEDURE
    READ
    TO
    WRITE

Grammar

Rule 0     S' -> PROGRAM
Rule 1     PROGRAM -> DECLARATIONS BLOCK
Rule 2     BLOCK -> BEGIN COMMAND_LIST END
Rule 3     BLOCK -> BEGIN END
Rule 4     DECLARATIONS -> CONST_DEF TYPE_DEF VAR_DEF
Rule 5     CONST_DEF -> CONSTANT CONST_DEF
Rule 6     CONST_DEF -> <empty>
Rule 7     CONSTANT -> CONST ID = CONST_VALUE ;
Rule 8     CONST_VALUE -> STRING
Rule 9     CONST_VALUE -> CONST_EXP
Rule 10    CONST_EXP -> NUMBER
Rule 11    CONST_EXP -> ( CONST_EXP )
Rule 12    CONST_EXP -> CONST_EXP + CONST_EXP
Rule 13    CONST_EXP -> CONST_EXP - CONST_EXP
Rule 14    CONST_EXP -> CONST_EXP * CONST_EXP
Rule 15    CONST_EXP -> CONST_EXP / CONST_EXP
Rule 16    TYPE_DEF -> TYPE_DECLARATION TYPE_DEF
Rule 17    TYPE_DEF -> <empty>
Rule 18    TYPE_DECLARATION -> TYPE ID = DATA_TYPE ;
Rule 19    DATA_TYPE -> INTEGER
Rule 20    DATA_TYPE -> REAL
Rule 21    DATA_TYPE -> CHAR
Rule 22    DATA_TYPE -> BOOLEAN
Rule 23    DATA_TYPE -> ARRAY [ NUMBER ] OF DATA_TYPE
Rule 24    DATA_TYPE -> RECORD FIELDS END
Rule 25    DATA_TYPE -> ID
Rule 26    VAR_DEF -> VARIABLE VAR_DEF
Rule 27    VAR_DEF -> <empty>
Rule 28    VARIABLE -> VAR ID_LIST : DATA_TYPE ;
Rule 29    ID_LIST -> ID
Rule 30    ID_LIST -> ID_LIST , ID
Rule 31    FIELDS -> FIELD FIELD_LIST
Rule 32    FIELD -> ID : DATA_TYPE
Rule 33    FIELD_LIST -> ; FIELD FIELD_LIST
Rule 34    FIELD_LIST -> <empty>
Rule 35    COMMAND_LIST -> COMMAND
Rule 36    COMMAND_LIST -> COMMAND_LIST ; COMMAND
Rule 37    COMMAND -> ASSIGN_STATEMENT
Rule 38    COMMAND -> FUNCTION_CALL
Rule 39    COMMAND -> CONDITIONAL
Rule 40    COMMAND -> LOOP
Rule 41    COMMAND -> BLOCK
Rule 42    ASSIGN_STATEMENT -> ID ASSIGNMENT EXP
Rule 43    FUNCTION_CALL -> ID ( PARAM_LIST )
Rule 44    CONDITIONAL -> IF ( COM_EXP ) THEN COMMAND
Rule 45    CONDITIONAL -> IF ( COM_EXP ) THEN COMMAND ELSE COMMAND
Rule 46    LOOP -> WHILE ( COM_EXP ) DO COMMAND
Rule 47    PARAM_LIST -> EXP
Rule 48    PARAM_LIST -> PARAM_LIST , EXP
Rule 49    PARAM_LIST -> <empty>
Rule 50    COM_EXP -> EXP COMP_OP EXP
Rule 51    COM_EXP -> COM_EXP LOGIC_OP_OR COM_EXP
Rule 52    COM_EXP -> COM_EXP LOGIC_OP_AND COM_EXP
Rule 53    EXP -> EXP + EXP
Rule 54    EXP -> EXP - EXP
Rule 55    EXP -> EXP * EXP
Rule 56    EXP -> EXP / EXP
Rule 57    EXP -> ( EXP )
Rule 58    EXP -> ID
Rule 59    EXP -> NUMBER
Rule 60    EXP -> TRUE
Rule 61    EXP -> FALSE
Rule 62    EXP -> - EXP

Terminals, with rules where they appear

(                    : 11 43 44 45 46 57
)                    : 11 43 44 45 46 57
*                    : 14 55
+                    : 12 53
,                    : 30 48
-                    : 13 54 62
/                    : 15 56
:                    : 28 32
;                    : 7 18 28 33 36
=                    : 7 18
ARRAY                : 23
ASSIGNMENT           : 42
BEGIN                : 2 3
BOOLEAN              : 22
CHAR                 : 21
COMP_OP              : 50
CONST                : 7
DO                   : 46
ELSE                 : 45
END                  : 2 3 24
EQUAL                : 
FALSE                : 61
FOR                  : 
FUNCTION             : 
GREATER_EQUAL        : 
GREATER_THAN         : 
ID                   : 7 18 25 29 30 32 42 43 58
IF                   : 44 45
INTEGER              : 19
LESS_EQUAL           : 
LESS_THAN            : 
LOGIC_OP_AND         : 52
LOGIC_OP_OR          : 51
NOT_EQUALS           : 
NUMBER               : 10 23 59
OF                   : 23
PROCEDURE            : 
READ                 : 
REAL                 : 20
RECORD               : 24
STRING               : 8
THEN                 : 44 45
TO                   : 
TRUE                 : 60
TYPE                 : 18
VAR                  : 28
WHILE                : 46
WRITE                : 
[                    : 23
]                    : 23
error                : 

Nonterminals, with rules where they appear

ASSIGN_STATEMENT     : 37
BLOCK                : 1 41
COMMAND              : 35 36 44 45 45 46
COMMAND_LIST         : 2 36
COM_EXP              : 44 45 46 51 51 52 52
CONDITIONAL          : 39
CONSTANT             : 5
CONST_DEF            : 4 5
CONST_EXP            : 9 11 12 12 13 13 14 14 15 15
CONST_VALUE          : 7
DATA_TYPE            : 18 23 28 32
DECLARATIONS         : 1
EXP                  : 42 47 48 50 50 53 53 54 54 55 55 56 56 57 62
FIELD                : 31 33
FIELDS               : 24
FIELD_LIST           : 31 33
FUNCTION_CALL        : 38
ID_LIST              : 28 30
LOOP                 : 40
PARAM_LIST           : 43 48
PROGRAM              : 0
TYPE_DECLARATION     : 16
TYPE_DEF             : 4 16
VARIABLE             : 26
VAR_DEF              : 4 26

Parsing method: LALR

state 0

    (0) S' -> . PROGRAM
    (1) PROGRAM -> . DECLARATIONS BLOCK
    (4) DECLARATIONS -> . CONST_DEF TYPE_DEF VAR_DEF
    (5) CONST_DEF -> . CONSTANT CONST_DEF
    (6) CONST_DEF -> .
    (7) CONSTANT -> . CONST ID = CONST_VALUE ;

    TYPE            reduce using rule 6 (CONST_DEF -> .)
    VAR             reduce using rule 6 (CONST_DEF -> .)
    BEGIN           reduce using rule 6 (CONST_DEF -> .)
    CONST           shift and go to state 5

    PROGRAM                        shift and go to state 1
    DECLARATIONS                   shift and go to state 2
    CONST_DEF                      shift and go to state 3
    CONSTANT                       shift and go to state 4

state 1

    (0) S' -> PROGRAM .



state 2

    (1) PROGRAM -> DECLARATIONS . BLOCK
    (2) BLOCK -> . BEGIN COMMAND_LIST END
    (3) BLOCK -> . BEGIN END

    BEGIN           shift and go to state 7

    BLOCK                          shift and go to state 6

state 3

    (4) DECLARATIONS -> CONST_DEF . TYPE_DEF VAR_DEF
    (16) TYPE_DEF -> . TYPE_DECLARATION TYPE_DEF
    (17) TYPE_DEF -> .
    (18) TYPE_DECLARATION -> . TYPE ID = DATA_TYPE ;

    VAR             reduce using rule 17 (TYPE_DEF -> .)
    BEGIN           reduce using rule 17 (TYPE_DEF -> .)
    TYPE            shift and go to state 10

    TYPE_DEF                       shift and go to state 8
    TYPE_DECLARATION               shift and go to state 9

state 4

    (5) CONST_DEF -> CONSTANT . CONST_DEF
    (5) CONST_DEF -> . CONSTANT CONST_DEF
    (6) CONST_DEF -> .
    (7) CONSTANT -> . CONST ID = CONST_VALUE ;

    TYPE            reduce using rule 6 (CONST_DEF -> .)
    VAR             reduce using rule 6 (CONST_DEF -> .)
    BEGIN           reduce using rule 6 (CONST_DEF -> .)
    CONST           shift and go to state 5

    CONSTANT                       shift and go to state 4
    CONST_DEF                      shift and go to state 11

state 5

    (7) CONSTANT -> CONST . ID = CONST_VALUE ;

    ID              shift and go to state 12


state 6

    (1) PROGRAM -> DECLARATIONS BLOCK .

    $end            reduce using rule 1 (PROGRAM -> DECLARATIONS BLOCK .)


state 7

    (2) BLOCK -> BEGIN . COMMAND_LIST END
    (3) BLOCK -> BEGIN . END
    (35) COMMAND_LIST -> . COMMAND
    (36) COMMAND_LIST -> . COMMAND_LIST ; COMMAND
    (37) COMMAND -> . ASSIGN_STATEMENT
    (38) COMMAND -> . FUNCTION_CALL
    (39) COMMAND -> . CONDITIONAL
    (40) COMMAND -> . LOOP
    (41) COMMAND -> . BLOCK
    (42) ASSIGN_STATEMENT -> . ID ASSIGNMENT EXP
    (43) FUNCTION_CALL -> . ID ( PARAM_LIST )
    (44) CONDITIONAL -> . IF ( COM_EXP ) THEN COMMAND
    (45) CONDITIONAL -> . IF ( COM_EXP ) THEN COMMAND ELSE COMMAND
    (46) LOOP -> . WHILE ( COM_EXP ) DO COMMAND
    (2) BLOCK -> . BEGIN COMMAND_LIST END
    (3) BLOCK -> . BEGIN END

    END             shift and go to state 14
    ID              shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    BEGIN           shift and go to state 7

    COMMAND_LIST                   shift and go to state 13
    COMMAND                        shift and go to state 15
    ASSIGN_STATEMENT               shift and go to state 16
    FUNCTION_CALL                  shift and go to state 17
    CONDITIONAL                    shift and go to state 18
    LOOP                           shift and go to state 19
    BLOCK                          shift and go to state 20

state 8

    (4) DECLARATIONS -> CONST_DEF TYPE_DEF . VAR_DEF
    (26) VAR_DEF -> . VARIABLE VAR_DEF
    (27) VAR_DEF -> .
    (28) VARIABLE -> . VAR ID_LIST : DATA_TYPE ;

    BEGIN           reduce using rule 27 (VAR_DEF -> .)
    VAR             shift and go to state 26

    VAR_DEF                        shift and go to state 24
    VARIABLE                       shift and go to state 25

state 9

    (16) TYPE_DEF -> TYPE_DECLARATION . TYPE_DEF
    (16) TYPE_DEF -> . TYPE_DECLARATION TYPE_DEF
    (17) TYPE_DEF -> .
    (18) TYPE_DECLARATION -> . TYPE ID = DATA_TYPE ;

    VAR             reduce using rule 17 (TYPE_DEF -> .)
    BEGIN           reduce using rule 17 (TYPE_DEF -> .)
    TYPE            shift and go to state 10

    TYPE_DECLARATION               shift and go to state 9
    TYPE_DEF                       shift and go to state 27

state 10

    (18) TYPE_DECLARATION -> TYPE . ID = DATA_TYPE ;

    ID              shift and go to state 28


state 11

    (5) CONST_DEF -> CONSTANT CONST_DEF .

    TYPE            reduce using rule 5 (CONST_DEF -> CONSTANT CONST_DEF .)
    VAR             reduce using rule 5 (CONST_DEF -> CONSTANT CONST_DEF .)
    BEGIN           reduce using rule 5 (CONST_DEF -> CONSTANT CONST_DEF .)


state 12

    (7) CONSTANT -> CONST ID . = CONST_VALUE ;

    =               shift and go to state 29


state 13

    (2) BLOCK -> BEGIN COMMAND_LIST . END
    (36) COMMAND_LIST -> COMMAND_LIST . ; COMMAND

    END             shift and go to state 30
    ;               shift and go to state 31


state 14

    (3) BLOCK -> BEGIN END .

    $end            reduce using rule 3 (BLOCK -> BEGIN END .)
    END             reduce using rule 3 (BLOCK -> BEGIN END .)
    ;               reduce using rule 3 (BLOCK -> BEGIN END .)
    ELSE            reduce using rule 3 (BLOCK -> BEGIN END .)


state 15

    (35) COMMAND_LIST -> COMMAND .

    END             reduce using rule 35 (COMMAND_LIST -> COMMAND .)
    ;               reduce using rule 35 (COMMAND_LIST -> COMMAND .)


state 16

    (37) COMMAND -> ASSIGN_STATEMENT .

    END             reduce using rule 37 (COMMAND -> ASSIGN_STATEMENT .)
    ;               reduce using rule 37 (COMMAND -> ASSIGN_STATEMENT .)
    ELSE            reduce using rule 37 (COMMAND -> ASSIGN_STATEMENT .)


state 17

    (38) COMMAND -> FUNCTION_CALL .

    END             reduce using rule 38 (COMMAND -> FUNCTION_CALL .)
    ;               reduce using rule 38 (COMMAND -> FUNCTION_CALL .)
    ELSE            reduce using rule 38 (COMMAND -> FUNCTION_CALL .)


state 18

    (39) COMMAND -> CONDITIONAL .

    END             reduce using rule 39 (COMMAND -> CONDITIONAL .)
    ;               reduce using rule 39 (COMMAND -> CONDITIONAL .)
    ELSE            reduce using rule 39 (COMMAND -> CONDITIONAL .)


state 19

    (40) COMMAND -> LOOP .

    END             reduce using rule 40 (COMMAND -> LOOP .)
    ;               reduce using rule 40 (COMMAND -> LOOP .)
    ELSE            reduce using rule 40 (COMMAND -> LOOP .)


state 20

    (41) COMMAND -> BLOCK .

    END             reduce using rule 41 (COMMAND -> BLOCK .)
    ;               reduce using rule 41 (COMMAND -> BLOCK .)
    ELSE            reduce using rule 41 (COMMAND -> BLOCK .)


state 21

    (42) ASSIGN_STATEMENT -> ID . ASSIGNMENT EXP
    (43) FUNCTION_CALL -> ID . ( PARAM_LIST )

    ASSIGNMENT      shift and go to state 32
    (               shift and go to state 33


state 22

    (44) CONDITIONAL -> IF . ( COM_EXP ) THEN COMMAND
    (45) CONDITIONAL -> IF . ( COM_EXP ) THEN COMMAND ELSE COMMAND

    (               shift and go to state 34


state 23

    (46) LOOP -> WHILE . ( COM_EXP ) DO COMMAND

    (               shift and go to state 35


state 24

    (4) DECLARATIONS -> CONST_DEF TYPE_DEF VAR_DEF .

    BEGIN           reduce using rule 4 (DECLARATIONS -> CONST_DEF TYPE_DEF VAR_DEF .)


state 25

    (26) VAR_DEF -> VARIABLE . VAR_DEF
    (26) VAR_DEF -> . VARIABLE VAR_DEF
    (27) VAR_DEF -> .
    (28) VARIABLE -> . VAR ID_LIST : DATA_TYPE ;

    BEGIN           reduce using rule 27 (VAR_DEF -> .)
    VAR             shift and go to state 26

    VARIABLE                       shift and go to state 25
    VAR_DEF                        shift and go to state 36

state 26

    (28) VARIABLE -> VAR . ID_LIST : DATA_TYPE ;
    (29) ID_LIST -> . ID
    (30) ID_LIST -> . ID_LIST , ID

    ID              shift and go to state 38

    ID_LIST                        shift and go to state 37

state 27

    (16) TYPE_DEF -> TYPE_DECLARATION TYPE_DEF .

    VAR             reduce using rule 16 (TYPE_DEF -> TYPE_DECLARATION TYPE_DEF .)
    BEGIN           reduce using rule 16 (TYPE_DEF -> TYPE_DECLARATION TYPE_DEF .)


state 28

    (18) TYPE_DECLARATION -> TYPE ID . = DATA_TYPE ;

    =               shift and go to state 39


state 29

    (7) CONSTANT -> CONST ID = . CONST_VALUE ;
    (8) CONST_VALUE -> . STRING
    (9) CONST_VALUE -> . CONST_EXP
    (10) CONST_EXP -> . NUMBER
    (11) CONST_EXP -> . ( CONST_EXP )
    (12) CONST_EXP -> . CONST_EXP + CONST_EXP
    (13) CONST_EXP -> . CONST_EXP - CONST_EXP
    (14) CONST_EXP -> . CONST_EXP * CONST_EXP
    (15) CONST_EXP -> . CONST_EXP / CONST_EXP

    STRING          shift and go to state 41
    NUMBER          shift and go to state 43
    (               shift and go to state 44

    CONST_VALUE                    shift and go to state 40
    CONST_EXP                      shift and go to state 42

state 30

    (2) BLOCK -> BEGIN COMMAND_LIST END .

    $end            reduce using rule 2 (BLOCK -> BEGIN COMMAND_LIST END .)
    END             reduce using rule 2 (BLOCK -> BEGIN COMMAND_LIST END .)
    ;               reduce using rule 2 (BLOCK -> BEGIN COMMAND_LIST END .)
    ELSE            reduce using rule 2 (BLOCK -> BEGIN COMMAND_LIST END .)


state 31

    (36) COMMAND_LIST -> COMMAND_LIST ; . COMMAND
    (37) COMMAND -> . ASSIGN_STATEMENT
    (38) COMMAND -> . FUNCTION_CALL
    (39) COMMAND -> . CONDITIONAL
    (40) COMMAND -> . LOOP
    (41) COMMAND -> . BLOCK
    (42) ASSIGN_STATEMENT -> . ID ASSIGNMENT EXP
    (43) FUNCTION_CALL -> . ID ( PARAM_LIST )
    (44) CONDITIONAL -> . IF ( COM_EXP ) THEN COMMAND
    (45) CONDITIONAL -> . IF ( COM_EXP ) THEN COMMAND ELSE COMMAND
    (46) LOOP -> . WHILE ( COM_EXP ) DO COMMAND
    (2) BLOCK -> . BEGIN COMMAND_LIST END
    (3) BLOCK -> . BEGIN END

    ID              shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    BEGIN           shift and go to state 7

    COMMAND                        shift and go to state 45
    ASSIGN_STATEMENT               shift and go to state 16
    FUNCTION_CALL                  shift and go to state 17
    CONDITIONAL                    shift and go to state 18
    LOOP                           shift and go to state 19
    BLOCK                          shift and go to state 20

state 32

    (42) ASSIGN_STATEMENT -> ID ASSIGNMENT . EXP
    (53) EXP -> . EXP + EXP
    (54) EXP -> . EXP - EXP
    (55) EXP -> . EXP * EXP
    (56) EXP -> . EXP / EXP
    (57) EXP -> . ( EXP )
    (58) EXP -> . ID
    (59) EXP -> . NUMBER
    (60) EXP -> . TRUE
    (61) EXP -> . FALSE
    (62) EXP -> . - EXP

    (               shift and go to state 49
    ID              shift and go to state 46
    NUMBER          shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    -               shift and go to state 48

    EXP                            shift and go to state 47

state 33

    (43) FUNCTION_CALL -> ID ( . PARAM_LIST )
    (47) PARAM_LIST -> . EXP
    (48) PARAM_LIST -> . PARAM_LIST , EXP
    (49) PARAM_LIST -> .
    (53) EXP -> . EXP + EXP
    (54) EXP -> . EXP - EXP
    (55) EXP -> . EXP * EXP
    (56) EXP -> . EXP / EXP
    (57) EXP -> . ( EXP )
    (58) EXP -> . ID
    (59) EXP -> . NUMBER
    (60) EXP -> . TRUE
    (61) EXP -> . FALSE
    (62) EXP -> . - EXP

    )               reduce using rule 49 (PARAM_LIST -> .)
    ,               reduce using rule 49 (PARAM_LIST -> .)
    (               shift and go to state 49
    ID              shift and go to state 46
    NUMBER          shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    -               shift and go to state 48

    PARAM_LIST                     shift and go to state 53
    EXP                            shift and go to state 54

state 34

    (44) CONDITIONAL -> IF ( . COM_EXP ) THEN COMMAND
    (45) CONDITIONAL -> IF ( . COM_EXP ) THEN COMMAND ELSE COMMAND
    (50) COM_EXP -> . EXP COMP_OP EXP
    (51) COM_EXP -> . COM_EXP LOGIC_OP_OR COM_EXP
    (52) COM_EXP -> . COM_EXP LOGIC_OP_AND COM_EXP
    (53) EXP -> . EXP + EXP
    (54) EXP -> . EXP - EXP
    (55) EXP -> . EXP * EXP
    (56) EXP -> . EXP / EXP
    (57) EXP -> . ( EXP )
    (58) EXP -> . ID
    (59) EXP -> . NUMBER
    (60) EXP -> . TRUE
    (61) EXP -> . FALSE
    (62) EXP -> . - EXP

    (               shift and go to state 49
    ID              shift and go to state 46
    NUMBER          shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    -               shift and go to state 48

    COM_EXP                        shift and go to state 55
    EXP                            shift and go to state 56

state 35

    (46) LOOP -> WHILE ( . COM_EXP ) DO COMMAND
    (50) COM_EXP -> . EXP COMP_OP EXP
    (51) COM_EXP -> . COM_EXP LOGIC_OP_OR COM_EXP
    (52) COM_EXP -> . COM_EXP LOGIC_OP_AND COM_EXP
    (53) EXP -> . EXP + EXP
    (54) EXP -> . EXP - EXP
    (55) EXP -> . EXP * EXP
    (56) EXP -> . EXP / EXP
    (57) EXP -> . ( EXP )
    (58) EXP -> . ID
    (59) EXP -> . NUMBER
    (60) EXP -> . TRUE
    (61) EXP -> . FALSE
    (62) EXP -> . - EXP

    (               shift and go to state 49
    ID              shift and go to state 46
    NUMBER          shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    -               shift and go to state 48

    COM_EXP                        shift and go to state 57
    EXP                            shift and go to state 56

state 36

    (26) VAR_DEF -> VARIABLE VAR_DEF .

    BEGIN           reduce using rule 26 (VAR_DEF -> VARIABLE VAR_DEF .)


state 37

    (28) VARIABLE -> VAR ID_LIST . : DATA_TYPE ;
    (30) ID_LIST -> ID_LIST . , ID

    :               shift and go to state 58
    ,               shift and go to state 59


state 38

    (29) ID_LIST -> ID .

    :               reduce using rule 29 (ID_LIST -> ID .)
    ,               reduce using rule 29 (ID_LIST -> ID .)


state 39

    (18) TYPE_DECLARATION -> TYPE ID = . DATA_TYPE ;
    (19) DATA_TYPE -> . INTEGER
    (20) DATA_TYPE -> . REAL
    (21) DATA_TYPE -> . CHAR
    (22) DATA_TYPE -> . BOOLEAN
    (23) DATA_TYPE -> . ARRAY [ NUMBER ] OF DATA_TYPE
    (24) DATA_TYPE -> . RECORD FIELDS END
    (25) DATA_TYPE -> . ID

    INTEGER         shift and go to state 62
    REAL            shift and go to state 63
    CHAR            shift and go to state 64
    BOOLEAN         shift and go to state 65
    ARRAY           shift and go to state 66
    RECORD          shift and go to state 67
    ID              shift and go to state 60

    DATA_TYPE                      shift and go to state 61

state 40

    (7) CONSTANT -> CONST ID = CONST_VALUE . ;

    ;               shift and go to state 68


state 41

    (8) CONST_VALUE -> STRING .

    ;               reduce using rule 8 (CONST_VALUE -> STRING .)


state 42

    (9) CONST_VALUE -> CONST_EXP .
    (12) CONST_EXP -> CONST_EXP . + CONST_EXP
    (13) CONST_EXP -> CONST_EXP . - CONST_EXP
    (14) CONST_EXP -> CONST_EXP . * CONST_EXP
    (15) CONST_EXP -> CONST_EXP . / CONST_EXP

    ;               reduce using rule 9 (CONST_VALUE -> CONST_EXP .)
    +               shift and go to state 69
    -               shift and go to state 70
    *               shift and go to state 71
    /               shift and go to state 72


state 43

    (10) CONST_EXP -> NUMBER .

    +               reduce using rule 10 (CONST_EXP -> NUMBER .)
    -               reduce using rule 10 (CONST_EXP -> NUMBER .)
    *               reduce using rule 10 (CONST_EXP -> NUMBER .)
    /               reduce using rule 10 (CONST_EXP -> NUMBER .)
    ;               reduce using rule 10 (CONST_EXP -> NUMBER .)
    )               reduce using rule 10 (CONST_EXP -> NUMBER .)


state 44

    (11) CONST_EXP -> ( . CONST_EXP )
    (10) CONST_EXP -> . NUMBER
    (11) CONST_EXP -> . ( CONST_EXP )
    (12) CONST_EXP -> . CONST_EXP + CONST_EXP
    (13) CONST_EXP -> . CONST_EXP - CONST_EXP
    (14) CONST_EXP -> . CONST_EXP * CONST_EXP
    (15) CONST_EXP -> . CONST_EXP / CONST_EXP

    NUMBER          shift and go to state 43
    (               shift and go to state 44

    CONST_EXP                      shift and go to state 73

state 45

    (36) COMMAND_LIST -> COMMAND_LIST ; COMMAND .

    END             reduce using rule 36 (COMMAND_LIST -> COMMAND_LIST ; COMMAND .)
    ;               reduce using rule 36 (COMMAND_LIST -> COMMAND_LIST ; COMMAND .)


state 46

    (58) EXP -> ID .

    +               reduce using rule 58 (EXP -> ID .)
    -               reduce using rule 58 (EXP -> ID .)
    *               reduce using rule 58 (EXP -> ID .)
    /               reduce using rule 58 (EXP -> ID .)
    END             reduce using rule 58 (EXP -> ID .)
    ;               reduce using rule 58 (EXP -> ID .)
    ELSE            reduce using rule 58 (EXP -> ID .)
    )               reduce using rule 58 (EXP -> ID .)
    ,               reduce using rule 58 (EXP -> ID .)
    COMP_OP         reduce using rule 58 (EXP -> ID .)
    LOGIC_OP_OR     reduce using rule 58 (EXP -> ID .)
    LOGIC_OP_AND    reduce using rule 58 (EXP -> ID .)


state 47

    (42) ASSIGN_STATEMENT -> ID ASSIGNMENT EXP .
    (53) EXP -> EXP . + EXP
    (54) EXP -> EXP . - EXP
    (55) EXP -> EXP . * EXP
    (56) EXP -> EXP . / EXP

    END             reduce using rule 42 (ASSIGN_STATEMENT -> ID ASSIGNMENT EXP .)
    ;               reduce using rule 42 (ASSIGN_STATEMENT -> ID ASSIGNMENT EXP .)
    ELSE            reduce using rule 42 (ASSIGN_STATEMENT -> ID ASSIGNMENT EXP .)
    +               shift and go to state 74
    -               shift and go to state 75
    *               shift and go to state 76
    /               shift and go to state 77


state 48

    (62) EXP -> - . EXP
    (53) EXP -> . EXP + EXP
    (54) EXP -> . EXP - EXP
    (55) EXP -> . EXP * EXP
    (56) EXP -> . EXP / EXP
    (57) EXP -> . ( EXP )
    (58) EXP -> . ID
    (59) EXP -> . NUMBER
    (60) EXP -> . TRUE
    (61) EXP -> . FALSE
    (62) EXP -> . - EXP

    (               shift and go to state 49
    ID              shift and go to state 46
    NUMBER          shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    -               shift and go to state 48

    EXP                            shift and go to state 78

state 49

    (57) EXP -> ( . EXP )
    (53) EXP -> . EXP + EXP
    (54) EXP -> . EXP - EXP
    (55) EXP -> . EXP * EXP
    (56) EXP -> . EXP / EXP
    (57) EXP -> . ( EXP )
    (58) EXP -> . ID
    (59) EXP -> . NUMBER
    (60) EXP -> . TRUE
    (61) EXP -> . FALSE
    (62) EXP -> . - EXP

    (               shift and go to state 49
    ID              shift and go to state 46
    NUMBER          shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    -               shift and go to state 48

    EXP                            shift and go to state 79

state 50

    (59) EXP -> NUMBER .

    +               reduce using rule 59 (EXP -> NUMBER .)
    -               reduce using rule 59 (EXP -> NUMBER .)
    *               reduce using rule 59 (EXP -> NUMBER .)
    /               reduce using rule 59 (EXP -> NUMBER .)
    END             reduce using rule 59 (EXP -> NUMBER .)
    ;               reduce using rule 59 (EXP -> NUMBER .)
    ELSE            reduce using rule 59 (EXP -> NUMBER .)
    )               reduce using rule 59 (EXP -> NUMBER .)
    ,               reduce using rule 59 (EXP -> NUMBER .)
    COMP_OP         reduce using rule 59 (EXP -> NUMBER .)
    LOGIC_OP_OR     reduce using rule 59 (EXP -> NUMBER .)
    LOGIC_OP_AND    reduce using rule 59 (EXP -> NUMBER .)


state 51

    (60) EXP -> TRUE .

    +               reduce using rule 60 (EXP -> TRUE .)
    -               reduce using rule 60 (EXP -> TRUE .)
    *               reduce using rule 60 (EXP -> TRUE .)
    /               reduce using rule 60 (EXP -> TRUE .)
    END             reduce using rule 60 (EXP -> TRUE .)
    ;               reduce using rule 60 (EXP -> TRUE .)
    ELSE            reduce using rule 60 (EXP -> TRUE .)
    )               reduce using rule 60 (EXP -> TRUE .)
    ,               reduce using rule 60 (EXP -> TRUE .)
    COMP_OP         reduce using rule 60 (EXP -> TRUE .)
    LOGIC_OP_OR     reduce using rule 60 (EXP -> TRUE .)
    LOGIC_OP_AND    reduce using rule 60 (EXP -> TRUE .)


state 52

    (61) EXP -> FALSE .

    +               reduce using rule 61 (EXP -> FALSE .)
    -               reduce using rule 61 (EXP -> FALSE .)
    *               reduce using rule 61 (EXP -> FALSE .)
    /               reduce using rule 61 (EXP -> FALSE .)
    END             reduce using rule 61 (EXP -> FALSE .)
    ;               reduce using rule 61 (EXP -> FALSE .)
    ELSE            reduce using rule 61 (EXP -> FALSE .)
    )               reduce using rule 61 (EXP -> FALSE .)
    ,               reduce using rule 61 (EXP -> FALSE .)
    COMP_OP         reduce using rule 61 (EXP -> FALSE .)
    LOGIC_OP_OR     reduce using rule 61 (EXP -> FALSE .)
    LOGIC_OP_AND    reduce using rule 61 (EXP -> FALSE .)


state 53

    (43) FUNCTION_CALL -> ID ( PARAM_LIST . )
    (48) PARAM_LIST -> PARAM_LIST . , EXP

    )               shift and go to state 80
    ,               shift and go to state 81


state 54

    (47) PARAM_LIST -> EXP .
    (53) EXP -> EXP . + EXP
    (54) EXP -> EXP . - EXP
    (55) EXP -> EXP . * EXP
    (56) EXP -> EXP . / EXP

    )               reduce using rule 47 (PARAM_LIST -> EXP .)
    ,               reduce using rule 47 (PARAM_LIST -> EXP .)
    +               shift and go to state 74
    -               shift and go to state 75
    *               shift and go to state 76
    /               shift and go to state 77


state 55

    (44) CONDITIONAL -> IF ( COM_EXP . ) THEN COMMAND
    (45) CONDITIONAL -> IF ( COM_EXP . ) THEN COMMAND ELSE COMMAND
    (51) COM_EXP -> COM_EXP . LOGIC_OP_OR COM_EXP
    (52) COM_EXP -> COM_EXP . LOGIC_OP_AND COM_EXP

    )               shift and go to state 82
    LOGIC_OP_OR     shift and go to state 83
    LOGIC_OP_AND    shift and go to state 84


state 56

    (50) COM_EXP -> EXP . COMP_OP EXP
    (53) EXP -> EXP . + EXP
    (54) EXP -> EXP . - EXP
    (55) EXP -> EXP . * EXP
    (56) EXP -> EXP . / EXP

    COMP_OP         shift and go to state 85
    +               shift and go to state 74
    -               shift and go to state 75
    *               shift and go to state 76
    /               shift and go to state 77


state 57

    (46) LOOP -> WHILE ( COM_EXP . ) DO COMMAND
    (51) COM_EXP -> COM_EXP . LOGIC_OP_OR COM_EXP
    (52) COM_EXP -> COM_EXP . LOGIC_OP_AND COM_EXP

    )               shift and go to state 86
    LOGIC_OP_OR     shift and go to state 83
    LOGIC_OP_AND    shift and go to state 84


state 58

    (28) VARIABLE -> VAR ID_LIST : . DATA_TYPE ;
    (19) DATA_TYPE -> . INTEGER
    (20) DATA_TYPE -> . REAL
    (21) DATA_TYPE -> . CHAR
    (22) DATA_TYPE -> . BOOLEAN
    (23) DATA_TYPE -> . ARRAY [ NUMBER ] OF DATA_TYPE
    (24) DATA_TYPE -> . RECORD FIELDS END
    (25) DATA_TYPE -> . ID

    INTEGER         shift and go to state 62
    REAL            shift and go to state 63
    CHAR            shift and go to state 64
    BOOLEAN         shift and go to state 65
    ARRAY           shift and go to state 66
    RECORD          shift and go to state 67
    ID              shift and go to state 60

    DATA_TYPE                      shift and go to state 87

state 59

    (30) ID_LIST -> ID_LIST , . ID

    ID              shift and go to state 88


state 60

    (25) DATA_TYPE -> ID .

    ;               reduce using rule 25 (DATA_TYPE -> ID .)
    END             reduce using rule 25 (DATA_TYPE -> ID .)


state 61

    (18) TYPE_DECLARATION -> TYPE ID = DATA_TYPE . ;

    ;               shift and go to state 89


state 62

    (19) DATA_TYPE -> INTEGER .

    ;               reduce using rule 19 (DATA_TYPE -> INTEGER .)
    END             reduce using rule 19 (DATA_TYPE -> INTEGER .)


state 63

    (20) DATA_TYPE -> REAL .

    ;               reduce using rule 20 (DATA_TYPE -> REAL .)
    END             reduce using rule 20 (DATA_TYPE -> REAL .)


state 64

    (21) DATA_TYPE -> CHAR .

    ;               reduce using rule 21 (DATA_TYPE -> CHAR .)
    END             reduce using rule 21 (DATA_TYPE -> CHAR .)


state 65

    (22) DATA_TYPE -> BOOLEAN .

    ;               reduce using rule 22 (DATA_TYPE -> BOOLEAN .)
    END             reduce using rule 22 (DATA_TYPE -> BOOLEAN .)


state 66

    (23) DATA_TYPE -> ARRAY . [ NUMBER ] OF DATA_TYPE

    [               shift and go to state 90


state 67

    (24) DATA_TYPE -> RECORD . FIELDS END
    (31) FIELDS -> . FIELD FIELD_LIST
    (32) FIELD -> . ID : DATA_TYPE

    ID              shift and go to state 93

    FIELDS                         shift and go to state 91
    FIELD                          shift and go to state 92

state 68

    (7) CONSTANT -> CONST ID = CONST_VALUE ; .

    CONST           reduce using rule 7 (CONSTANT -> CONST ID = CONST_VALUE ; .)
    TYPE            reduce using rule 7 (CONSTANT -> CONST ID = CONST_VALUE ; .)
    VAR             reduce using rule 7 (CONSTANT -> CONST ID = CONST_VALUE ; .)
    BEGIN           reduce using rule 7 (CONSTANT -> CONST ID = CONST_VALUE ; .)


state 69

    (12) CONST_EXP -> CONST_EXP + . CONST_EXP
    (10) CONST_EXP -> . NUMBER
    (11) CONST_EXP -> . ( CONST_EXP )
    (12) CONST_EXP -> . CONST_EXP + CONST_EXP
    (13) CONST_EXP -> . CONST_EXP - CONST_EXP
    (14) CONST_EXP -> . CONST_EXP * CONST_EXP
    (15) CONST_EXP -> . CONST_EXP / CONST_EXP

    NUMBER          shift and go to state 43
    (               shift and go to state 44

    CONST_EXP                      shift and go to state 94

state 70

    (13) CONST_EXP -> CONST_EXP - . CONST_EXP
    (10) CONST_EXP -> . NUMBER
    (11) CONST_EXP -> . ( CONST_EXP )
    (12) CONST_EXP -> . CONST_EXP + CONST_EXP
    (13) CONST_EXP -> . CONST_EXP - CONST_EXP
    (14) CONST_EXP -> . CONST_EXP * CONST_EXP
    (15) CONST_EXP -> . CONST_EXP / CONST_EXP

    NUMBER          shift and go to state 43
    (               shift and go to state 44

    CONST_EXP                      shift and go to state 95

state 71

    (14) CONST_EXP -> CONST_EXP * . CONST_EXP
    (10) CONST_EXP -> . NUMBER
    (11) CONST_EXP -> . ( CONST_EXP )
    (12) CONST_EXP -> . CONST_EXP + CONST_EXP
    (13) CONST_EXP -> . CONST_EXP - CONST_EXP
    (14) CONST_EXP -> . CONST_EXP * CONST_EXP
    (15) CONST_EXP -> . CONST_EXP / CONST_EXP

    NUMBER          shift and go to state 43
    (               shift and go to state 44

    CONST_EXP                      shift and go to state 96

state 72

    (15) CONST_EXP -> CONST_EXP / . CONST_EXP
    (10) CONST_EXP -> . NUMBER
    (11) CONST_EXP -> . ( CONST_EXP )
    (12) CONST_EXP -> . CONST_EXP + CONST_EXP
    (13) CONST_EXP -> . CONST_EXP - CONST_EXP
    (14) CONST_EXP -> . CONST_EXP * CONST_EXP
    (15) CONST_EXP -> . CONST_EXP / CONST_EXP

    NUMBER          shift and go to state 43
    (               shift and go to state 44

    CONST_EXP                      shift and go to state 97

state 73

    (11) CONST_EXP -> ( CONST_EXP . )
    (12) CONST_EXP -> CONST_EXP . + CONST_EXP
    (13) CONST_EXP -> CONST_EXP . - CONST_EXP
    (14) CONST_EXP -> CONST_EXP . * CONST_EXP
    (15) CONST_EXP -> CONST_EXP . / CONST_EXP

    )               shift and go to state 98
    +               shift and go to state 69
    -               shift and go to state 70
    *               shift and go to state 71
    /               shift and go to state 72


state 74

    (53) EXP -> EXP + . EXP
    (53) EXP -> . EXP + EXP
    (54) EXP -> . EXP - EXP
    (55) EXP -> . EXP * EXP
    (56) EXP -> . EXP / EXP
    (57) EXP -> . ( EXP )
    (58) EXP -> . ID
    (59) EXP -> . NUMBER
    (60) EXP -> . TRUE
    (61) EXP -> . FALSE
    (62) EXP -> . - EXP

    (               shift and go to state 49
    ID              shift and go to state 46
    NUMBER          shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    -               shift and go to state 48

    EXP                            shift and go to state 99

state 75

    (54) EXP -> EXP - . EXP
    (53) EXP -> . EXP + EXP
    (54) EXP -> . EXP - EXP
    (55) EXP -> . EXP * EXP
    (56) EXP -> . EXP / EXP
    (57) EXP -> . ( EXP )
    (58) EXP -> . ID
    (59) EXP -> . NUMBER
    (60) EXP -> . TRUE
    (61) EXP -> . FALSE
    (62) EXP -> . - EXP

    (               shift and go to state 49
    ID              shift and go to state 46
    NUMBER          shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    -               shift and go to state 48

    EXP                            shift and go to state 100

state 76

    (55) EXP -> EXP * . EXP
    (53) EXP -> . EXP + EXP
    (54) EXP -> . EXP - EXP
    (55) EXP -> . EXP * EXP
    (56) EXP -> . EXP / EXP
    (57) EXP -> . ( EXP )
    (58) EXP -> . ID
    (59) EXP -> . NUMBER
    (60) EXP -> . TRUE
    (61) EXP -> . FALSE
    (62) EXP -> . - EXP

    (               shift and go to state 49
    ID              shift and go to state 46
    NUMBER          shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    -               shift and go to state 48

    EXP                            shift and go to state 101

state 77

    (56) EXP -> EXP / . EXP
    (53) EXP -> . EXP + EXP
    (54) EXP -> . EXP - EXP
    (55) EXP -> . EXP * EXP
    (56) EXP -> . EXP / EXP
    (57) EXP -> . ( EXP )
    (58) EXP -> . ID
    (59) EXP -> . NUMBER
    (60) EXP -> . TRUE
    (61) EXP -> . FALSE
    (62) EXP -> . - EXP

    (               shift and go to state 49
    ID              shift and go to state 46
    NUMBER          shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    -               shift and go to state 48

    EXP                            shift and go to state 102

state 78

    (62) EXP -> - EXP .
    (53) EXP -> EXP . + EXP
    (54) EXP -> EXP . - EXP
    (55) EXP -> EXP . * EXP
    (56) EXP -> EXP . / EXP

    +               reduce using rule 62 (EXP -> - EXP .)
    -               reduce using rule 62 (EXP -> - EXP .)
    *               reduce using rule 62 (EXP -> - EXP .)
    /               reduce using rule 62 (EXP -> - EXP .)
    END             reduce using rule 62 (EXP -> - EXP .)
    ;               reduce using rule 62 (EXP -> - EXP .)
    ELSE            reduce using rule 62 (EXP -> - EXP .)
    )               reduce using rule 62 (EXP -> - EXP .)
    ,               reduce using rule 62 (EXP -> - EXP .)
    COMP_OP         reduce using rule 62 (EXP -> - EXP .)
    LOGIC_OP_OR     reduce using rule 62 (EXP -> - EXP .)
    LOGIC_OP_AND    reduce using rule 62 (EXP -> - EXP .)

  ! +               [ shift and go to state 74 ]
  ! -               [ shift and go to state 75 ]
  ! *               [ shift and go to state 76 ]
  ! /               [ shift and go to state 77 ]


state 79

    (57) EXP -> ( EXP . )
    (53) EXP -> EXP . + EXP
    (54) EXP -> EXP . - EXP
    (55) EXP -> EXP . * EXP
    (56) EXP -> EXP . / EXP

    )               shift and go to state 103
    +               shift and go to state 74
    -               shift and go to state 75
    *               shift and go to state 76
    /               shift and go to state 77


state 80

    (43) FUNCTION_CALL -> ID ( PARAM_LIST ) .

    END             reduce using rule 43 (FUNCTION_CALL -> ID ( PARAM_LIST ) .)
    ;               reduce using rule 43 (FUNCTION_CALL -> ID ( PARAM_LIST ) .)
    ELSE            reduce using rule 43 (FUNCTION_CALL -> ID ( PARAM_LIST ) .)


state 81

    (48) PARAM_LIST -> PARAM_LIST , . EXP
    (53) EXP -> . EXP + EXP
    (54) EXP -> . EXP - EXP
    (55) EXP -> . EXP * EXP
    (56) EXP -> . EXP / EXP
    (57) EXP -> . ( EXP )
    (58) EXP -> . ID
    (59) EXP -> . NUMBER
    (60) EXP -> . TRUE
    (61) EXP -> . FALSE
    (62) EXP -> . - EXP

    (               shift and go to state 49
    ID              shift and go to state 46
    NUMBER          shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    -               shift and go to state 48

    EXP                            shift and go to state 104

state 82

    (44) CONDITIONAL -> IF ( COM_EXP ) . THEN COMMAND
    (45) CONDITIONAL -> IF ( COM_EXP ) . THEN COMMAND ELSE COMMAND

    THEN            shift and go to state 105


state 83

    (51) COM_EXP -> COM_EXP LOGIC_OP_OR . COM_EXP
    (50) COM_EXP -> . EXP COMP_OP EXP
    (51) COM_EXP -> . COM_EXP LOGIC_OP_OR COM_EXP
    (52) COM_EXP -> . COM_EXP LOGIC_OP_AND COM_EXP
    (53) EXP -> . EXP + EXP
    (54) EXP -> . EXP - EXP
    (55) EXP -> . EXP * EXP
    (56) EXP -> . EXP / EXP
    (57) EXP -> . ( EXP )
    (58) EXP -> . ID
    (59) EXP -> . NUMBER
    (60) EXP -> . TRUE
    (61) EXP -> . FALSE
    (62) EXP -> . - EXP

    (               shift and go to state 49
    ID              shift and go to state 46
    NUMBER          shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    -               shift and go to state 48

    COM_EXP                        shift and go to state 106
    EXP                            shift and go to state 56

state 84

    (52) COM_EXP -> COM_EXP LOGIC_OP_AND . COM_EXP
    (50) COM_EXP -> . EXP COMP_OP EXP
    (51) COM_EXP -> . COM_EXP LOGIC_OP_OR COM_EXP
    (52) COM_EXP -> . COM_EXP LOGIC_OP_AND COM_EXP
    (53) EXP -> . EXP + EXP
    (54) EXP -> . EXP - EXP
    (55) EXP -> . EXP * EXP
    (56) EXP -> . EXP / EXP
    (57) EXP -> . ( EXP )
    (58) EXP -> . ID
    (59) EXP -> . NUMBER
    (60) EXP -> . TRUE
    (61) EXP -> . FALSE
    (62) EXP -> . - EXP

    (               shift and go to state 49
    ID              shift and go to state 46
    NUMBER          shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    -               shift and go to state 48

    COM_EXP                        shift and go to state 107
    EXP                            shift and go to state 56

state 85

    (50) COM_EXP -> EXP COMP_OP . EXP
    (53) EXP -> . EXP + EXP
    (54) EXP -> . EXP - EXP
    (55) EXP -> . EXP * EXP
    (56) EXP -> . EXP / EXP
    (57) EXP -> . ( EXP )
    (58) EXP -> . ID
    (59) EXP -> . NUMBER
    (60) EXP -> . TRUE
    (61) EXP -> . FALSE
    (62) EXP -> . - EXP

    (               shift and go to state 49
    ID              shift and go to state 46
    NUMBER          shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    -               shift and go to state 48

    EXP                            shift and go to state 108

state 86

    (46) LOOP -> WHILE ( COM_EXP ) . DO COMMAND

    DO              shift and go to state 109


state 87

    (28) VARIABLE -> VAR ID_LIST : DATA_TYPE . ;

    ;               shift and go to state 110


state 88

    (30) ID_LIST -> ID_LIST , ID .

    :               reduce using rule 30 (ID_LIST -> ID_LIST , ID .)
    ,               reduce using rule 30 (ID_LIST -> ID_LIST , ID .)


state 89

    (18) TYPE_DECLARATION -> TYPE ID = DATA_TYPE ; .

    TYPE            reduce using rule 18 (TYPE_DECLARATION -> TYPE ID = DATA_TYPE ; .)
    VAR             reduce using rule 18 (TYPE_DECLARATION -> TYPE ID = DATA_TYPE ; .)
    BEGIN           reduce using rule 18 (TYPE_DECLARATION -> TYPE ID = DATA_TYPE ; .)


state 90

    (23) DATA_TYPE -> ARRAY [ . NUMBER ] OF DATA_TYPE

    NUMBER          shift and go to state 111


state 91

    (24) DATA_TYPE -> RECORD FIELDS . END

    END             shift and go to state 112


state 92

    (31) FIELDS -> FIELD . FIELD_LIST
    (33) FIELD_LIST -> . ; FIELD FIELD_LIST
    (34) FIELD_LIST -> .

    ;               shift and go to state 114
    END             reduce using rule 34 (FIELD_LIST -> .)

    FIELD_LIST                     shift and go to state 113

state 93

    (32) FIELD -> ID . : DATA_TYPE

    :               shift and go to state 115


state 94

    (12) CONST_EXP -> CONST_EXP + CONST_EXP .
    (12) CONST_EXP -> CONST_EXP . + CONST_EXP
    (13) CONST_EXP -> CONST_EXP . - CONST_EXP
    (14) CONST_EXP -> CONST_EXP . * CONST_EXP
    (15) CONST_EXP -> CONST_EXP . / CONST_EXP

    +               reduce using rule 12 (CONST_EXP -> CONST_EXP + CONST_EXP .)
    -               reduce using rule 12 (CONST_EXP -> CONST_EXP + CONST_EXP .)
    ;               reduce using rule 12 (CONST_EXP -> CONST_EXP + CONST_EXP .)
    )               reduce using rule 12 (CONST_EXP -> CONST_EXP + CONST_EXP .)
    *               shift and go to state 71
    /               shift and go to state 72

  ! *               [ reduce using rule 12 (CONST_EXP -> CONST_EXP + CONST_EXP .) ]
  ! /               [ reduce using rule 12 (CONST_EXP -> CONST_EXP + CONST_EXP .) ]
  ! +               [ shift and go to state 69 ]
  ! -               [ shift and go to state 70 ]


state 95

    (13) CONST_EXP -> CONST_EXP - CONST_EXP .
    (12) CONST_EXP -> CONST_EXP . + CONST_EXP
    (13) CONST_EXP -> CONST_EXP . - CONST_EXP
    (14) CONST_EXP -> CONST_EXP . * CONST_EXP
    (15) CONST_EXP -> CONST_EXP . / CONST_EXP

    +               reduce using rule 13 (CONST_EXP -> CONST_EXP - CONST_EXP .)
    -               reduce using rule 13 (CONST_EXP -> CONST_EXP - CONST_EXP .)
    ;               reduce using rule 13 (CONST_EXP -> CONST_EXP - CONST_EXP .)
    )               reduce using rule 13 (CONST_EXP -> CONST_EXP - CONST_EXP .)
    *               shift and go to state 71
    /               shift and go to state 72

  ! *               [ reduce using rule 13 (CONST_EXP -> CONST_EXP - CONST_EXP .) ]
  ! /               [ reduce using rule 13 (CONST_EXP -> CONST_EXP - CONST_EXP .) ]
  ! +               [ shift and go to state 69 ]
  ! -               [ shift and go to state 70 ]


state 96

    (14) CONST_EXP -> CONST_EXP * CONST_EXP .
    (12) CONST_EXP -> CONST_EXP . + CONST_EXP
    (13) CONST_EXP -> CONST_EXP . - CONST_EXP
    (14) CONST_EXP -> CONST_EXP . * CONST_EXP
    (15) CONST_EXP -> CONST_EXP . / CONST_EXP

    +               reduce using rule 14 (CONST_EXP -> CONST_EXP * CONST_EXP .)
    -               reduce using rule 14 (CONST_EXP -> CONST_EXP * CONST_EXP .)
    *               reduce using rule 14 (CONST_EXP -> CONST_EXP * CONST_EXP .)
    /               reduce using rule 14 (CONST_EXP -> CONST_EXP * CONST_EXP .)
    ;               reduce using rule 14 (CONST_EXP -> CONST_EXP * CONST_EXP .)
    )               reduce using rule 14 (CONST_EXP -> CONST_EXP * CONST_EXP .)

  ! +               [ shift and go to state 69 ]
  ! -               [ shift and go to state 70 ]
  ! *               [ shift and go to state 71 ]
  ! /               [ shift and go to state 72 ]


state 97

    (15) CONST_EXP -> CONST_EXP / CONST_EXP .
    (12) CONST_EXP -> CONST_EXP . + CONST_EXP
    (13) CONST_EXP -> CONST_EXP . - CONST_EXP
    (14) CONST_EXP -> CONST_EXP . * CONST_EXP
    (15) CONST_EXP -> CONST_EXP . / CONST_EXP

    +               reduce using rule 15 (CONST_EXP -> CONST_EXP / CONST_EXP .)
    -               reduce using rule 15 (CONST_EXP -> CONST_EXP / CONST_EXP .)
    *               reduce using rule 15 (CONST_EXP -> CONST_EXP / CONST_EXP .)
    /               reduce using rule 15 (CONST_EXP -> CONST_EXP / CONST_EXP .)
    ;               reduce using rule 15 (CONST_EXP -> CONST_EXP / CONST_EXP .)
    )               reduce using rule 15 (CONST_EXP -> CONST_EXP / CONST_EXP .)

  ! +               [ shift and go to state 69 ]
  ! -               [ shift and go to state 70 ]
  ! *               [ shift and go to state 71 ]
  ! /               [ shift and go to state 72 ]


state 98

    (11) CONST_EXP -> ( CONST_EXP ) .

    +               reduce using rule 11 (CONST_EXP -> ( CONST_EXP ) .)
    -               reduce using rule 11 (CONST_EXP -> ( CONST_EXP ) .)
    *               reduce using rule 11 (CONST_EXP -> ( CONST_EXP ) .)
    /               reduce using rule 11 (CONST_EXP -> ( CONST_EXP ) .)
    ;               reduce using rule 11 (CONST_EXP -> ( CONST_EXP ) .)
    )               reduce using rule 11 (CONST_EXP -> ( CONST_EXP ) .)


state 99

    (53) EXP -> EXP + EXP .
    (53) EXP -> EXP . + EXP
    (54) EXP -> EXP . - EXP
    (55) EXP -> EXP . * EXP
    (56) EXP -> EXP . / EXP

    +               reduce using rule 53 (EXP -> EXP + EXP .)
    -               reduce using rule 53 (EXP -> EXP + EXP .)
    END             reduce using rule 53 (EXP -> EXP + EXP .)
    ;               reduce using rule 53 (EXP -> EXP + EXP .)
    ELSE            reduce using rule 53 (EXP -> EXP + EXP .)
    )               reduce using rule 53 (EXP -> EXP + EXP .)
    ,               reduce using rule 53 (EXP -> EXP + EXP .)
    COMP_OP         reduce using rule 53 (EXP -> EXP + EXP .)
    LOGIC_OP_OR     reduce using rule 53 (EXP -> EXP + EXP .)
    LOGIC_OP_AND    reduce using rule 53 (EXP -> EXP + EXP .)
    *               shift and go to state 76
    /               shift and go to state 77

  ! *               [ reduce using rule 53 (EXP -> EXP + EXP .) ]
  ! /               [ reduce using rule 53 (EXP -> EXP + EXP .) ]
  ! +               [ shift and go to state 74 ]
  ! -               [ shift and go to state 75 ]


state 100

    (54) EXP -> EXP - EXP .
    (53) EXP -> EXP . + EXP
    (54) EXP -> EXP . - EXP
    (55) EXP -> EXP . * EXP
    (56) EXP -> EXP . / EXP

    +               reduce using rule 54 (EXP -> EXP - EXP .)
    -               reduce using rule 54 (EXP -> EXP - EXP .)
    END             reduce using rule 54 (EXP -> EXP - EXP .)
    ;               reduce using rule 54 (EXP -> EXP - EXP .)
    ELSE            reduce using rule 54 (EXP -> EXP - EXP .)
    )               reduce using rule 54 (EXP -> EXP - EXP .)
    ,               reduce using rule 54 (EXP -> EXP - EXP .)
    COMP_OP         reduce using rule 54 (EXP -> EXP - EXP .)
    LOGIC_OP_OR     reduce using rule 54 (EXP -> EXP - EXP .)
    LOGIC_OP_AND    reduce using rule 54 (EXP -> EXP - EXP .)
    *               shift and go to state 76
    /               shift and go to state 77

  ! *               [ reduce using rule 54 (EXP -> EXP - EXP .) ]
  ! /               [ reduce using rule 54 (EXP -> EXP - EXP .) ]
  ! +               [ shift and go to state 74 ]
  ! -               [ shift and go to state 75 ]


state 101

    (55) EXP -> EXP * EXP .
    (53) EXP -> EXP . + EXP
    (54) EXP -> EXP . - EXP
    (55) EXP -> EXP . * EXP
    (56) EXP -> EXP . / EXP

    +               reduce using rule 55 (EXP -> EXP * EXP .)
    -               reduce using rule 55 (EXP -> EXP * EXP .)
    *               reduce using rule 55 (EXP -> EXP * EXP .)
    /               reduce using rule 55 (EXP -> EXP * EXP .)
    END             reduce using rule 55 (EXP -> EXP * EXP .)
    ;               reduce using rule 55 (EXP -> EXP * EXP .)
    ELSE            reduce using rule 55 (EXP -> EXP * EXP .)
    )               reduce using rule 55 (EXP -> EXP * EXP .)
    ,               reduce using rule 55 (EXP -> EXP * EXP .)
    COMP_OP         reduce using rule 55 (EXP -> EXP * EXP .)
    LOGIC_OP_OR     reduce using rule 55 (EXP -> EXP * EXP .)
    LOGIC_OP_AND    reduce using rule 55 (EXP -> EXP * EXP .)

  ! +               [ shift and go to state 74 ]
  ! -               [ shift and go to state 75 ]
  ! *               [ shift and go to state 76 ]
  ! /               [ shift and go to state 77 ]


state 102

    (56) EXP -> EXP / EXP .
    (53) EXP -> EXP . + EXP
    (54) EXP -> EXP . - EXP
    (55) EXP -> EXP . * EXP
    (56) EXP -> EXP . / EXP

    +               reduce using rule 56 (EXP -> EXP / EXP .)
    -               reduce using rule 56 (EXP -> EXP / EXP .)
    *               reduce using rule 56 (EXP -> EXP / EXP .)
    /               reduce using rule 56 (EXP -> EXP / EXP .)
    END             reduce using rule 56 (EXP -> EXP / EXP .)
    ;               reduce using rule 56 (EXP -> EXP / EXP .)
    ELSE            reduce using rule 56 (EXP -> EXP / EXP .)
    )               reduce using rule 56 (EXP -> EXP / EXP .)
    ,               reduce using rule 56 (EXP -> EXP / EXP .)
    COMP_OP         reduce using rule 56 (EXP -> EXP / EXP .)
    LOGIC_OP_OR     reduce using rule 56 (EXP -> EXP / EXP .)
    LOGIC_OP_AND    reduce using rule 56 (EXP -> EXP / EXP .)

  ! +               [ shift and go to state 74 ]
  ! -               [ shift and go to state 75 ]
  ! *               [ shift and go to state 76 ]
  ! /               [ shift and go to state 77 ]


state 103

    (57) EXP -> ( EXP ) .

    +               reduce using rule 57 (EXP -> ( EXP ) .)
    -               reduce using rule 57 (EXP -> ( EXP ) .)
    *               reduce using rule 57 (EXP -> ( EXP ) .)
    /               reduce using rule 57 (EXP -> ( EXP ) .)
    END             reduce using rule 57 (EXP -> ( EXP ) .)
    ;               reduce using rule 57 (EXP -> ( EXP ) .)
    ELSE            reduce using rule 57 (EXP -> ( EXP ) .)
    )               reduce using rule 57 (EXP -> ( EXP ) .)
    ,               reduce using rule 57 (EXP -> ( EXP ) .)
    COMP_OP         reduce using rule 57 (EXP -> ( EXP ) .)
    LOGIC_OP_OR     reduce using rule 57 (EXP -> ( EXP ) .)
    LOGIC_OP_AND    reduce using rule 57 (EXP -> ( EXP ) .)


state 104

    (48) PARAM_LIST -> PARAM_LIST , EXP .
    (53) EXP -> EXP . + EXP
    (54) EXP -> EXP . - EXP
    (55) EXP -> EXP . * EXP
    (56) EXP -> EXP . / EXP

    )               reduce using rule 48 (PARAM_LIST -> PARAM_LIST , EXP .)
    ,               reduce using rule 48 (PARAM_LIST -> PARAM_LIST , EXP .)
    +               shift and go to state 74
    -               shift and go to state 75
    *               shift and go to state 76
    /               shift and go to state 77


state 105

    (44) CONDITIONAL -> IF ( COM_EXP ) THEN . COMMAND
    (45) CONDITIONAL -> IF ( COM_EXP ) THEN . COMMAND ELSE COMMAND
    (37) COMMAND -> . ASSIGN_STATEMENT
    (38) COMMAND -> . FUNCTION_CALL
    (39) COMMAND -> . CONDITIONAL
    (40) COMMAND -> . LOOP
    (41) COMMAND -> . BLOCK
    (42) ASSIGN_STATEMENT -> . ID ASSIGNMENT EXP
    (43) FUNCTION_CALL -> . ID ( PARAM_LIST )
    (44) CONDITIONAL -> . IF ( COM_EXP ) THEN COMMAND
    (45) CONDITIONAL -> . IF ( COM_EXP ) THEN COMMAND ELSE COMMAND
    (46) LOOP -> . WHILE ( COM_EXP ) DO COMMAND
    (2) BLOCK -> . BEGIN COMMAND_LIST END
    (3) BLOCK -> . BEGIN END

    ID              shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    BEGIN           shift and go to state 7

    COMMAND                        shift and go to state 116
    ASSIGN_STATEMENT               shift and go to state 16
    FUNCTION_CALL                  shift and go to state 17
    CONDITIONAL                    shift and go to state 18
    LOOP                           shift and go to state 19
    BLOCK                          shift and go to state 20

state 106

    (51) COM_EXP -> COM_EXP LOGIC_OP_OR COM_EXP .
    (51) COM_EXP -> COM_EXP . LOGIC_OP_OR COM_EXP
    (52) COM_EXP -> COM_EXP . LOGIC_OP_AND COM_EXP

    )               reduce using rule 51 (COM_EXP -> COM_EXP LOGIC_OP_OR COM_EXP .)
    LOGIC_OP_OR     reduce using rule 51 (COM_EXP -> COM_EXP LOGIC_OP_OR COM_EXP .)
    LOGIC_OP_AND    shift and go to state 84

  ! LOGIC_OP_AND    [ reduce using rule 51 (COM_EXP -> COM_EXP LOGIC_OP_OR COM_EXP .) ]
  ! LOGIC_OP_OR     [ shift and go to state 83 ]


state 107

    (52) COM_EXP -> COM_EXP LOGIC_OP_AND COM_EXP .
    (51) COM_EXP -> COM_EXP . LOGIC_OP_OR COM_EXP
    (52) COM_EXP -> COM_EXP . LOGIC_OP_AND COM_EXP

    )               reduce using rule 52 (COM_EXP -> COM_EXP LOGIC_OP_AND COM_EXP .)
    LOGIC_OP_OR     reduce using rule 52 (COM_EXP -> COM_EXP LOGIC_OP_AND COM_EXP .)
    LOGIC_OP_AND    reduce using rule 52 (COM_EXP -> COM_EXP LOGIC_OP_AND COM_EXP .)

  ! LOGIC_OP_OR     [ shift and go to state 83 ]
  ! LOGIC_OP_AND    [ shift and go to state 84 ]


state 108

    (50) COM_EXP -> EXP COMP_OP EXP .
    (53) EXP -> EXP . + EXP
    (54) EXP -> EXP . - EXP
    (55) EXP -> EXP . * EXP
    (56) EXP -> EXP . / EXP

    )               reduce using rule 50 (COM_EXP -> EXP COMP_OP EXP .)
    LOGIC_OP_OR     reduce using rule 50 (COM_EXP -> EXP COMP_OP EXP .)
    LOGIC_OP_AND    reduce using rule 50 (COM_EXP -> EXP COMP_OP EXP .)
    +               shift and go to state 74
    -               shift and go to state 75
    *               shift and go to state 76
    /               shift and go to state 77


state 109

    (46) LOOP -> WHILE ( COM_EXP ) DO . COMMAND
    (37) COMMAND -> . ASSIGN_STATEMENT
    (38) COMMAND -> . FUNCTION_CALL
    (39) COMMAND -> . CONDITIONAL
    (40) COMMAND -> . LOOP
    (41) COMMAND -> . BLOCK
    (42) ASSIGN_STATEMENT -> . ID ASSIGNMENT EXP
    (43) FUNCTION_CALL -> . ID ( PARAM_LIST )
    (44) CONDITIONAL -> . IF ( COM_EXP ) THEN COMMAND
    (45) CONDITIONAL -> . IF ( COM_EXP ) THEN COMMAND ELSE COMMAND
    (46) LOOP -> . WHILE ( COM_EXP ) DO COMMAND
    (2) BLOCK -> . BEGIN COMMAND_LIST END
    (3) BLOCK -> . BEGIN END

    ID              shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    BEGIN           shift and go to state 7

    COMMAND                        shift and go to state 117
    ASSIGN_STATEMENT               shift and go to state 16
    FUNCTION_CALL                  shift and go to state 17
    CONDITIONAL                    shift and go to state 18
    LOOP                           shift and go to state 19
    BLOCK                          shift and go to state 20

state 110

    (28) VARIABLE -> VAR ID_LIST : DATA_TYPE ; .

    VAR             reduce using rule 28 (VARIABLE -> VAR ID_LIST : DATA_TYPE ; .)
    BEGIN           reduce using rule 28 (VARIABLE -> VAR ID_LIST : DATA_TYPE ; .)


state 111

    (23) DATA_TYPE -> ARRAY [ NUMBER . ] OF DATA_TYPE

    ]               shift and go to state 118


state 112

    (24) DATA_TYPE -> RECORD FIELDS END .

    ;               reduce using rule 24 (DATA_TYPE -> RECORD FIELDS END .)
    END             reduce using rule 24 (DATA_TYPE -> RECORD FIELDS END .)


state 113

    (31) FIELDS -> FIELD FIELD_LIST .

    END             reduce using rule 31 (FIELDS -> FIELD FIELD_LIST .)


state 114

    (33) FIELD_LIST -> ; . FIELD FIELD_LIST
    (32) FIELD -> . ID : DATA_TYPE

    ID              shift and go to state 93

    FIELD                          shift and go to state 119

state 115

    (32) FIELD -> ID : . DATA_TYPE
    (19) DATA_TYPE -> . INTEGER
    (20) DATA_TYPE -> . REAL
    (21) DATA_TYPE -> . CHAR
    (22) DATA_TYPE -> . BOOLEAN
    (23) DATA_TYPE -> . ARRAY [ NUMBER ] OF DATA_TYPE
    (24) DATA_TYPE -> . RECORD FIELDS END
    (25) DATA_TYPE -> . ID

    INTEGER         shift and go to state 62
    REAL            shift and go to state 63
    CHAR            shift and go to state 64
    BOOLEAN         shift and go to state 65
    ARRAY           shift and go to state 66
    RECORD          shift and go to state 67
    ID              shift and go to state 60

    DATA_TYPE                      shift and go to state 120

state 116

    (44) CONDITIONAL -> IF ( COM_EXP ) THEN COMMAND .
    (45) CONDITIONAL -> IF ( COM_EXP ) THEN COMMAND . ELSE COMMAND

  ! shift/reduce conflict for ELSE resolved as shift
    END             reduce using rule 44 (CONDITIONAL -> IF ( COM_EXP ) THEN COMMAND .)
    ;               reduce using rule 44 (CONDITIONAL -> IF ( COM_EXP ) THEN COMMAND .)
    ELSE            shift and go to state 121

  ! ELSE            [ reduce using rule 44 (CONDITIONAL -> IF ( COM_EXP ) THEN COMMAND .) ]


state 117

    (46) LOOP -> WHILE ( COM_EXP ) DO COMMAND .

    END             reduce using rule 46 (LOOP -> WHILE ( COM_EXP ) DO COMMAND .)
    ;               reduce using rule 46 (LOOP -> WHILE ( COM_EXP ) DO COMMAND .)
    ELSE            reduce using rule 46 (LOOP -> WHILE ( COM_EXP ) DO COMMAND .)


state 118

    (23) DATA_TYPE -> ARRAY [ NUMBER ] . OF DATA_TYPE

    OF              shift and go to state 122


state 119

    (33) FIELD_LIST -> ; FIELD . FIELD_LIST
    (33) FIELD_LIST -> . ; FIELD FIELD_LIST
    (34) FIELD_LIST -> .

    ;               shift and go to state 114
    END             reduce using rule 34 (FIELD_LIST -> .)

    FIELD_LIST                     shift and go to state 123

state 120

    (32) FIELD -> ID : DATA_TYPE .

    ;               reduce using rule 32 (FIELD -> ID : DATA_TYPE .)
    END             reduce using rule 32 (FIELD -> ID : DATA_TYPE .)


state 121

    (45) CONDITIONAL -> IF ( COM_EXP ) THEN COMMAND ELSE . COMMAND
    (37) COMMAND -> . ASSIGN_STATEMENT
    (38) COMMAND -> . FUNCTION_CALL
    (39) COMMAND -> . CONDITIONAL
    (40) COMMAND -> . LOOP
    (41) COMMAND -> . BLOCK
    (42) ASSIGN_STATEMENT -> . ID ASSIGNMENT EXP
    (43) FUNCTION_CALL -> . ID ( PARAM_LIST )
    (44) CONDITIONAL -> . IF ( COM_EXP ) THEN COMMAND
    (45) CONDITIONAL -> . IF ( COM_EXP ) THEN COMMAND ELSE COMMAND
    (46) LOOP -> . WHILE ( COM_EXP ) DO COMMAND
    (2) BLOCK -> . BEGIN COMMAND_LIST END
    (3) BLOCK -> . BEGIN END

    ID              shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    BEGIN           shift and go to state 7

    COMMAND                        shift and go to state 124
    ASSIGN_STATEMENT               shift and go to state 16
    FUNCTION_CALL                  shift and go to state 17
    CONDITIONAL                    shift and go to state 18
    LOOP                           shift and go to state 19
    BLOCK                          shift and go to state 20

state 122

    (23) DATA_TYPE -> ARRAY [ NUMBER ] OF . DATA_TYPE
    (19) DATA_TYPE -> . INTEGER
    (20) DATA_TYPE -> . REAL
    (21) DATA_TYPE -> . CHAR
    (22) DATA_TYPE -> . BOOLEAN
    (23) DATA_TYPE -> . ARRAY [ NUMBER ] OF DATA_TYPE
    (24) DATA_TYPE -> . RECORD FIELDS END
    (25) DATA_TYPE -> . ID

    INTEGER         shift and go to state 62
    REAL            shift and go to state 63
    CHAR            shift and go to state 64
    BOOLEAN         shift and go to state 65
    ARRAY           shift and go to state 66
    RECORD          shift and go to state 67
    ID              shift and go to state 60

    DATA_TYPE                      shift and go to state 125

state 123

    (33) FIELD_LIST -> ; FIELD FIELD_LIST .

    END             reduce using rule 33 (FIELD_LIST -> ; FIELD FIELD_LIST .)


state 124

    (45) CONDITIONAL -> IF ( COM_EXP ) THEN COMMAND ELSE COMMAND .

    END             reduce using rule 45 (CONDITIONAL -> IF ( COM_EXP ) THEN COMMAND ELSE COMMAND .)
    ;               reduce using rule 45 (CONDITIONAL -> IF ( COM_EXP ) THEN COMMAND ELSE COMMAND .)
    ELSE            reduce using rule 45 (CONDITIONAL -> IF ( COM_EXP ) THEN COMMAND ELSE COMMAND .)


state 125

    (23) DATA_TYPE -> ARRAY [ NUMBER ] OF DATA_TYPE .

    ;               reduce using rule 23 (DATA_TYPE -> ARRAY [ NUMBER ] OF DATA_TYPE .)
    END             reduce using rule 23 (DATA_TYPE -> ARRAY [ NUMBER ] OF DATA_TYPE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 116 resolved as shift
