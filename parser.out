Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    EQUAL
    FOR
    FUNCTION
    GREATER_EQUAL
    GREATER_THAN
    LESS_EQUAL
    LESS_THAN
    NOT_EQUALS
    PROCEDURE
    READ
    TO
    WRITE

Grammar

Rule 0     S' -> PROGRAM
Rule 1     PROGRAM -> DECLARATIONS BLOCK
Rule 2     BLOCK -> BEGIN COMMAND_LIST END
Rule 3     BLOCK -> BEGIN END
Rule 4     DECLARATIONS -> CONST_DEF TYPE_DEF VAR_DEF
Rule 5     CONST_DEF -> CONSTANT CONST_DEF
Rule 6     CONST_DEF -> <empty>
Rule 7     CONSTANT -> CONST ID = CONST_VALUE ;
Rule 8     CONST_VALUE -> STRING
Rule 9     CONST_VALUE -> CONST_EXP
Rule 10    CONST_EXP -> NUMBER
Rule 11    CONST_EXP -> ( CONST_EXP )
Rule 12    CONST_EXP -> CONST_EXP + CONST_EXP
Rule 13    CONST_EXP -> CONST_EXP - CONST_EXP
Rule 14    CONST_EXP -> CONST_EXP * CONST_EXP
Rule 15    CONST_EXP -> CONST_EXP / CONST_EXP
Rule 16    TYPE_DEF -> TYPE_DECLARATION TYPE_DEF
Rule 17    TYPE_DEF -> <empty>
Rule 18    TYPE_DECLARATION -> TYPE ID = DATA_TYPE ;
Rule 19    DATA_TYPE -> INTEGER
Rule 20    DATA_TYPE -> REAL
Rule 21    DATA_TYPE -> CHAR
Rule 22    DATA_TYPE -> BOOLEAN
Rule 23    DATA_TYPE -> ARRAY [ NUMBER ] OF DATA_TYPE
Rule 24    DATA_TYPE -> RECORD FIELDS END
Rule 25    DATA_TYPE -> ID
Rule 26    VAR_DEF -> VARIABLE VAR_DEF
Rule 27    VAR_DEF -> <empty>
Rule 28    VARIABLE -> VAR ID_LIST : DATA_TYPE ;
Rule 29    ID_LIST -> ID
Rule 30    ID_LIST -> ID_LIST , ID
Rule 31    FIELDS -> FIELD FIELD_LIST
Rule 32    FIELD -> ID : DATA_TYPE
Rule 33    FIELD_LIST -> ; FIELD FIELD_LIST
Rule 34    FIELD_LIST -> <empty>
Rule 35    COMMAND_LIST -> COMMAND
Rule 36    COMMAND_LIST -> COMMAND_LIST ; COMMAND
Rule 37    COMMAND -> IF ( COM_EXP ) THEN COMMAND
Rule 38    COMMAND -> IF ( COM_EXP ) THEN COMMAND ELSE COMMAND
Rule 39    COMMAND -> WHILE ( COM_EXP ) DO COMMAND
Rule 40    COMMAND -> BEGIN COMMAND_LIST END
Rule 41    COMMAND -> ID ASSIGNMENT EXP
Rule 42    COMMAND -> ID ASSIGNMENT FUNCTION_CALL
Rule 43    FUNCTION_CALL -> ID ( PARAM_LIST )
Rule 44    PARAM_LIST -> EXP
Rule 45    PARAM_LIST -> PARAM_LIST , EXP
Rule 46    PARAM_LIST -> <empty>
Rule 47    COM_EXP -> EXP COMP_OP EXP
Rule 48    COM_EXP -> COM_EXP LOGIC_OP_OR COM_EXP
Rule 49    COM_EXP -> COM_EXP LOGIC_OP_AND COM_EXP
Rule 50    EXP -> EXP + EXP
Rule 51    EXP -> EXP - EXP
Rule 52    EXP -> EXP * EXP
Rule 53    EXP -> EXP / EXP
Rule 54    EXP -> ( EXP )
Rule 55    EXP -> ID
Rule 56    EXP -> NUMBER
Rule 57    EXP -> TRUE
Rule 58    EXP -> FALSE

Terminals, with rules where they appear

(                    : 11 37 38 39 43 54
)                    : 11 37 38 39 43 54
*                    : 14 52
+                    : 12 50
,                    : 30 45
-                    : 13 51
/                    : 15 53
:                    : 28 32
;                    : 7 18 28 33 36
=                    : 7 18
ARRAY                : 23
ASSIGNMENT           : 41 42
BEGIN                : 2 3 40
BOOLEAN              : 22
CHAR                 : 21
COMP_OP              : 47
CONST                : 7
DO                   : 39
ELSE                 : 38
END                  : 2 3 24 40
EQUAL                : 
FALSE                : 58
FOR                  : 
FUNCTION             : 
GREATER_EQUAL        : 
GREATER_THAN         : 
ID                   : 7 18 25 29 30 32 41 42 43 55
IF                   : 37 38
INTEGER              : 19
LESS_EQUAL           : 
LESS_THAN            : 
LOGIC_OP_AND         : 49
LOGIC_OP_OR          : 48
NOT_EQUALS           : 
NUMBER               : 10 23 56
OF                   : 23
PROCEDURE            : 
READ                 : 
REAL                 : 20
RECORD               : 24
STRING               : 8
THEN                 : 37 38
TO                   : 
TRUE                 : 57
TYPE                 : 18
VAR                  : 28
WHILE                : 39
WRITE                : 
[                    : 23
]                    : 23
error                : 

Nonterminals, with rules where they appear

BLOCK                : 1
COMMAND              : 35 36 37 38 38 39
COMMAND_LIST         : 2 36 40
COM_EXP              : 37 38 39 48 48 49 49
CONSTANT             : 5
CONST_DEF            : 4 5
CONST_EXP            : 9 11 12 12 13 13 14 14 15 15
CONST_VALUE          : 7
DATA_TYPE            : 18 23 28 32
DECLARATIONS         : 1
EXP                  : 41 44 45 47 47 50 50 51 51 52 52 53 53 54
FIELD                : 31 33
FIELDS               : 24
FIELD_LIST           : 31 33
FUNCTION_CALL        : 42
ID_LIST              : 28 30
PARAM_LIST           : 43 45
PROGRAM              : 0
TYPE_DECLARATION     : 16
TYPE_DEF             : 4 16
VARIABLE             : 26
VAR_DEF              : 4 26

Parsing method: LALR

state 0

    (0) S' -> . PROGRAM
    (1) PROGRAM -> . DECLARATIONS BLOCK
    (4) DECLARATIONS -> . CONST_DEF TYPE_DEF VAR_DEF
    (5) CONST_DEF -> . CONSTANT CONST_DEF
    (6) CONST_DEF -> .
    (7) CONSTANT -> . CONST ID = CONST_VALUE ;

    TYPE            reduce using rule 6 (CONST_DEF -> .)
    VAR             reduce using rule 6 (CONST_DEF -> .)
    BEGIN           reduce using rule 6 (CONST_DEF -> .)
    CONST           shift and go to state 5

    PROGRAM                        shift and go to state 1
    DECLARATIONS                   shift and go to state 2
    CONST_DEF                      shift and go to state 3
    CONSTANT                       shift and go to state 4

state 1

    (0) S' -> PROGRAM .



state 2

    (1) PROGRAM -> DECLARATIONS . BLOCK
    (2) BLOCK -> . BEGIN COMMAND_LIST END
    (3) BLOCK -> . BEGIN END

    BEGIN           shift and go to state 7

    BLOCK                          shift and go to state 6

state 3

    (4) DECLARATIONS -> CONST_DEF . TYPE_DEF VAR_DEF
    (16) TYPE_DEF -> . TYPE_DECLARATION TYPE_DEF
    (17) TYPE_DEF -> .
    (18) TYPE_DECLARATION -> . TYPE ID = DATA_TYPE ;

    VAR             reduce using rule 17 (TYPE_DEF -> .)
    BEGIN           reduce using rule 17 (TYPE_DEF -> .)
    TYPE            shift and go to state 10

    TYPE_DEF                       shift and go to state 8
    TYPE_DECLARATION               shift and go to state 9

state 4

    (5) CONST_DEF -> CONSTANT . CONST_DEF
    (5) CONST_DEF -> . CONSTANT CONST_DEF
    (6) CONST_DEF -> .
    (7) CONSTANT -> . CONST ID = CONST_VALUE ;

    TYPE            reduce using rule 6 (CONST_DEF -> .)
    VAR             reduce using rule 6 (CONST_DEF -> .)
    BEGIN           reduce using rule 6 (CONST_DEF -> .)
    CONST           shift and go to state 5

    CONSTANT                       shift and go to state 4
    CONST_DEF                      shift and go to state 11

state 5

    (7) CONSTANT -> CONST . ID = CONST_VALUE ;

    ID              shift and go to state 12


state 6

    (1) PROGRAM -> DECLARATIONS BLOCK .

    $end            reduce using rule 1 (PROGRAM -> DECLARATIONS BLOCK .)


state 7

    (2) BLOCK -> BEGIN . COMMAND_LIST END
    (3) BLOCK -> BEGIN . END
    (35) COMMAND_LIST -> . COMMAND
    (36) COMMAND_LIST -> . COMMAND_LIST ; COMMAND
    (37) COMMAND -> . IF ( COM_EXP ) THEN COMMAND
    (38) COMMAND -> . IF ( COM_EXP ) THEN COMMAND ELSE COMMAND
    (39) COMMAND -> . WHILE ( COM_EXP ) DO COMMAND
    (40) COMMAND -> . BEGIN COMMAND_LIST END
    (41) COMMAND -> . ID ASSIGNMENT EXP
    (42) COMMAND -> . ID ASSIGNMENT FUNCTION_CALL

    END             shift and go to state 15
    IF              shift and go to state 17
    WHILE           shift and go to state 18
    BEGIN           shift and go to state 13
    ID              shift and go to state 19

    COMMAND_LIST                   shift and go to state 14
    COMMAND                        shift and go to state 16

state 8

    (4) DECLARATIONS -> CONST_DEF TYPE_DEF . VAR_DEF
    (26) VAR_DEF -> . VARIABLE VAR_DEF
    (27) VAR_DEF -> .
    (28) VARIABLE -> . VAR ID_LIST : DATA_TYPE ;

    BEGIN           reduce using rule 27 (VAR_DEF -> .)
    VAR             shift and go to state 22

    VAR_DEF                        shift and go to state 20
    VARIABLE                       shift and go to state 21

state 9

    (16) TYPE_DEF -> TYPE_DECLARATION . TYPE_DEF
    (16) TYPE_DEF -> . TYPE_DECLARATION TYPE_DEF
    (17) TYPE_DEF -> .
    (18) TYPE_DECLARATION -> . TYPE ID = DATA_TYPE ;

    VAR             reduce using rule 17 (TYPE_DEF -> .)
    BEGIN           reduce using rule 17 (TYPE_DEF -> .)
    TYPE            shift and go to state 10

    TYPE_DECLARATION               shift and go to state 9
    TYPE_DEF                       shift and go to state 23

state 10

    (18) TYPE_DECLARATION -> TYPE . ID = DATA_TYPE ;

    ID              shift and go to state 24


state 11

    (5) CONST_DEF -> CONSTANT CONST_DEF .

    TYPE            reduce using rule 5 (CONST_DEF -> CONSTANT CONST_DEF .)
    VAR             reduce using rule 5 (CONST_DEF -> CONSTANT CONST_DEF .)
    BEGIN           reduce using rule 5 (CONST_DEF -> CONSTANT CONST_DEF .)


state 12

    (7) CONSTANT -> CONST ID . = CONST_VALUE ;

    =               shift and go to state 25


state 13

    (40) COMMAND -> BEGIN . COMMAND_LIST END
    (35) COMMAND_LIST -> . COMMAND
    (36) COMMAND_LIST -> . COMMAND_LIST ; COMMAND
    (37) COMMAND -> . IF ( COM_EXP ) THEN COMMAND
    (38) COMMAND -> . IF ( COM_EXP ) THEN COMMAND ELSE COMMAND
    (39) COMMAND -> . WHILE ( COM_EXP ) DO COMMAND
    (40) COMMAND -> . BEGIN COMMAND_LIST END
    (41) COMMAND -> . ID ASSIGNMENT EXP
    (42) COMMAND -> . ID ASSIGNMENT FUNCTION_CALL

    IF              shift and go to state 17
    WHILE           shift and go to state 18
    BEGIN           shift and go to state 13
    ID              shift and go to state 19

    COMMAND_LIST                   shift and go to state 26
    COMMAND                        shift and go to state 16

state 14

    (2) BLOCK -> BEGIN COMMAND_LIST . END
    (36) COMMAND_LIST -> COMMAND_LIST . ; COMMAND

    END             shift and go to state 27
    ;               shift and go to state 28


state 15

    (3) BLOCK -> BEGIN END .

    $end            reduce using rule 3 (BLOCK -> BEGIN END .)


state 16

    (35) COMMAND_LIST -> COMMAND .

    END             reduce using rule 35 (COMMAND_LIST -> COMMAND .)
    ;               reduce using rule 35 (COMMAND_LIST -> COMMAND .)


state 17

    (37) COMMAND -> IF . ( COM_EXP ) THEN COMMAND
    (38) COMMAND -> IF . ( COM_EXP ) THEN COMMAND ELSE COMMAND

    (               shift and go to state 29


state 18

    (39) COMMAND -> WHILE . ( COM_EXP ) DO COMMAND

    (               shift and go to state 30


state 19

    (41) COMMAND -> ID . ASSIGNMENT EXP
    (42) COMMAND -> ID . ASSIGNMENT FUNCTION_CALL

    ASSIGNMENT      shift and go to state 31


state 20

    (4) DECLARATIONS -> CONST_DEF TYPE_DEF VAR_DEF .

    BEGIN           reduce using rule 4 (DECLARATIONS -> CONST_DEF TYPE_DEF VAR_DEF .)


state 21

    (26) VAR_DEF -> VARIABLE . VAR_DEF
    (26) VAR_DEF -> . VARIABLE VAR_DEF
    (27) VAR_DEF -> .
    (28) VARIABLE -> . VAR ID_LIST : DATA_TYPE ;

    BEGIN           reduce using rule 27 (VAR_DEF -> .)
    VAR             shift and go to state 22

    VARIABLE                       shift and go to state 21
    VAR_DEF                        shift and go to state 32

state 22

    (28) VARIABLE -> VAR . ID_LIST : DATA_TYPE ;
    (29) ID_LIST -> . ID
    (30) ID_LIST -> . ID_LIST , ID

    ID              shift and go to state 34

    ID_LIST                        shift and go to state 33

state 23

    (16) TYPE_DEF -> TYPE_DECLARATION TYPE_DEF .

    VAR             reduce using rule 16 (TYPE_DEF -> TYPE_DECLARATION TYPE_DEF .)
    BEGIN           reduce using rule 16 (TYPE_DEF -> TYPE_DECLARATION TYPE_DEF .)


state 24

    (18) TYPE_DECLARATION -> TYPE ID . = DATA_TYPE ;

    =               shift and go to state 35


state 25

    (7) CONSTANT -> CONST ID = . CONST_VALUE ;
    (8) CONST_VALUE -> . STRING
    (9) CONST_VALUE -> . CONST_EXP
    (10) CONST_EXP -> . NUMBER
    (11) CONST_EXP -> . ( CONST_EXP )
    (12) CONST_EXP -> . CONST_EXP + CONST_EXP
    (13) CONST_EXP -> . CONST_EXP - CONST_EXP
    (14) CONST_EXP -> . CONST_EXP * CONST_EXP
    (15) CONST_EXP -> . CONST_EXP / CONST_EXP

    STRING          shift and go to state 37
    NUMBER          shift and go to state 39
    (               shift and go to state 40

    CONST_VALUE                    shift and go to state 36
    CONST_EXP                      shift and go to state 38

state 26

    (40) COMMAND -> BEGIN COMMAND_LIST . END
    (36) COMMAND_LIST -> COMMAND_LIST . ; COMMAND

    END             shift and go to state 41
    ;               shift and go to state 28


state 27

    (2) BLOCK -> BEGIN COMMAND_LIST END .

    $end            reduce using rule 2 (BLOCK -> BEGIN COMMAND_LIST END .)


state 28

    (36) COMMAND_LIST -> COMMAND_LIST ; . COMMAND
    (37) COMMAND -> . IF ( COM_EXP ) THEN COMMAND
    (38) COMMAND -> . IF ( COM_EXP ) THEN COMMAND ELSE COMMAND
    (39) COMMAND -> . WHILE ( COM_EXP ) DO COMMAND
    (40) COMMAND -> . BEGIN COMMAND_LIST END
    (41) COMMAND -> . ID ASSIGNMENT EXP
    (42) COMMAND -> . ID ASSIGNMENT FUNCTION_CALL

    IF              shift and go to state 17
    WHILE           shift and go to state 18
    BEGIN           shift and go to state 13
    ID              shift and go to state 19

    COMMAND                        shift and go to state 42

state 29

    (37) COMMAND -> IF ( . COM_EXP ) THEN COMMAND
    (38) COMMAND -> IF ( . COM_EXP ) THEN COMMAND ELSE COMMAND
    (47) COM_EXP -> . EXP COMP_OP EXP
    (48) COM_EXP -> . COM_EXP LOGIC_OP_OR COM_EXP
    (49) COM_EXP -> . COM_EXP LOGIC_OP_AND COM_EXP
    (50) EXP -> . EXP + EXP
    (51) EXP -> . EXP - EXP
    (52) EXP -> . EXP * EXP
    (53) EXP -> . EXP / EXP
    (54) EXP -> . ( EXP )
    (55) EXP -> . ID
    (56) EXP -> . NUMBER
    (57) EXP -> . TRUE
    (58) EXP -> . FALSE

    (               shift and go to state 43
    ID              shift and go to state 46
    NUMBER          shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49

    COM_EXP                        shift and go to state 44
    EXP                            shift and go to state 45

state 30

    (39) COMMAND -> WHILE ( . COM_EXP ) DO COMMAND
    (47) COM_EXP -> . EXP COMP_OP EXP
    (48) COM_EXP -> . COM_EXP LOGIC_OP_OR COM_EXP
    (49) COM_EXP -> . COM_EXP LOGIC_OP_AND COM_EXP
    (50) EXP -> . EXP + EXP
    (51) EXP -> . EXP - EXP
    (52) EXP -> . EXP * EXP
    (53) EXP -> . EXP / EXP
    (54) EXP -> . ( EXP )
    (55) EXP -> . ID
    (56) EXP -> . NUMBER
    (57) EXP -> . TRUE
    (58) EXP -> . FALSE

    (               shift and go to state 43
    ID              shift and go to state 46
    NUMBER          shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49

    COM_EXP                        shift and go to state 50
    EXP                            shift and go to state 45

state 31

    (41) COMMAND -> ID ASSIGNMENT . EXP
    (42) COMMAND -> ID ASSIGNMENT . FUNCTION_CALL
    (50) EXP -> . EXP + EXP
    (51) EXP -> . EXP - EXP
    (52) EXP -> . EXP * EXP
    (53) EXP -> . EXP / EXP
    (54) EXP -> . ( EXP )
    (55) EXP -> . ID
    (56) EXP -> . NUMBER
    (57) EXP -> . TRUE
    (58) EXP -> . FALSE
    (43) FUNCTION_CALL -> . ID ( PARAM_LIST )

    (               shift and go to state 43
    ID              shift and go to state 51
    NUMBER          shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49

    EXP                            shift and go to state 52
    FUNCTION_CALL                  shift and go to state 53

state 32

    (26) VAR_DEF -> VARIABLE VAR_DEF .

    BEGIN           reduce using rule 26 (VAR_DEF -> VARIABLE VAR_DEF .)


state 33

    (28) VARIABLE -> VAR ID_LIST . : DATA_TYPE ;
    (30) ID_LIST -> ID_LIST . , ID

    :               shift and go to state 54
    ,               shift and go to state 55


state 34

    (29) ID_LIST -> ID .

    :               reduce using rule 29 (ID_LIST -> ID .)
    ,               reduce using rule 29 (ID_LIST -> ID .)


state 35

    (18) TYPE_DECLARATION -> TYPE ID = . DATA_TYPE ;
    (19) DATA_TYPE -> . INTEGER
    (20) DATA_TYPE -> . REAL
    (21) DATA_TYPE -> . CHAR
    (22) DATA_TYPE -> . BOOLEAN
    (23) DATA_TYPE -> . ARRAY [ NUMBER ] OF DATA_TYPE
    (24) DATA_TYPE -> . RECORD FIELDS END
    (25) DATA_TYPE -> . ID

    INTEGER         shift and go to state 58
    REAL            shift and go to state 59
    CHAR            shift and go to state 60
    BOOLEAN         shift and go to state 61
    ARRAY           shift and go to state 62
    RECORD          shift and go to state 63
    ID              shift and go to state 56

    DATA_TYPE                      shift and go to state 57

state 36

    (7) CONSTANT -> CONST ID = CONST_VALUE . ;

    ;               shift and go to state 64


state 37

    (8) CONST_VALUE -> STRING .

    ;               reduce using rule 8 (CONST_VALUE -> STRING .)


state 38

    (9) CONST_VALUE -> CONST_EXP .
    (12) CONST_EXP -> CONST_EXP . + CONST_EXP
    (13) CONST_EXP -> CONST_EXP . - CONST_EXP
    (14) CONST_EXP -> CONST_EXP . * CONST_EXP
    (15) CONST_EXP -> CONST_EXP . / CONST_EXP

    ;               reduce using rule 9 (CONST_VALUE -> CONST_EXP .)
    +               shift and go to state 65
    -               shift and go to state 66
    *               shift and go to state 67
    /               shift and go to state 68


state 39

    (10) CONST_EXP -> NUMBER .

    +               reduce using rule 10 (CONST_EXP -> NUMBER .)
    -               reduce using rule 10 (CONST_EXP -> NUMBER .)
    *               reduce using rule 10 (CONST_EXP -> NUMBER .)
    /               reduce using rule 10 (CONST_EXP -> NUMBER .)
    ;               reduce using rule 10 (CONST_EXP -> NUMBER .)
    )               reduce using rule 10 (CONST_EXP -> NUMBER .)


state 40

    (11) CONST_EXP -> ( . CONST_EXP )
    (10) CONST_EXP -> . NUMBER
    (11) CONST_EXP -> . ( CONST_EXP )
    (12) CONST_EXP -> . CONST_EXP + CONST_EXP
    (13) CONST_EXP -> . CONST_EXP - CONST_EXP
    (14) CONST_EXP -> . CONST_EXP * CONST_EXP
    (15) CONST_EXP -> . CONST_EXP / CONST_EXP

    NUMBER          shift and go to state 39
    (               shift and go to state 40

    CONST_EXP                      shift and go to state 69

state 41

    (40) COMMAND -> BEGIN COMMAND_LIST END .

    END             reduce using rule 40 (COMMAND -> BEGIN COMMAND_LIST END .)
    ;               reduce using rule 40 (COMMAND -> BEGIN COMMAND_LIST END .)
    ELSE            reduce using rule 40 (COMMAND -> BEGIN COMMAND_LIST END .)


state 42

    (36) COMMAND_LIST -> COMMAND_LIST ; COMMAND .

    END             reduce using rule 36 (COMMAND_LIST -> COMMAND_LIST ; COMMAND .)
    ;               reduce using rule 36 (COMMAND_LIST -> COMMAND_LIST ; COMMAND .)


state 43

    (54) EXP -> ( . EXP )
    (50) EXP -> . EXP + EXP
    (51) EXP -> . EXP - EXP
    (52) EXP -> . EXP * EXP
    (53) EXP -> . EXP / EXP
    (54) EXP -> . ( EXP )
    (55) EXP -> . ID
    (56) EXP -> . NUMBER
    (57) EXP -> . TRUE
    (58) EXP -> . FALSE

    (               shift and go to state 43
    ID              shift and go to state 46
    NUMBER          shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49

    EXP                            shift and go to state 70

state 44

    (37) COMMAND -> IF ( COM_EXP . ) THEN COMMAND
    (38) COMMAND -> IF ( COM_EXP . ) THEN COMMAND ELSE COMMAND
    (48) COM_EXP -> COM_EXP . LOGIC_OP_OR COM_EXP
    (49) COM_EXP -> COM_EXP . LOGIC_OP_AND COM_EXP

    )               shift and go to state 71
    LOGIC_OP_OR     shift and go to state 72
    LOGIC_OP_AND    shift and go to state 73


state 45

    (47) COM_EXP -> EXP . COMP_OP EXP
    (50) EXP -> EXP . + EXP
    (51) EXP -> EXP . - EXP
    (52) EXP -> EXP . * EXP
    (53) EXP -> EXP . / EXP

    COMP_OP         shift and go to state 74
    +               shift and go to state 75
    -               shift and go to state 76
    *               shift and go to state 77
    /               shift and go to state 78


state 46

    (55) EXP -> ID .

    COMP_OP         reduce using rule 55 (EXP -> ID .)
    +               reduce using rule 55 (EXP -> ID .)
    -               reduce using rule 55 (EXP -> ID .)
    *               reduce using rule 55 (EXP -> ID .)
    /               reduce using rule 55 (EXP -> ID .)
    )               reduce using rule 55 (EXP -> ID .)
    LOGIC_OP_OR     reduce using rule 55 (EXP -> ID .)
    LOGIC_OP_AND    reduce using rule 55 (EXP -> ID .)
    END             reduce using rule 55 (EXP -> ID .)
    ;               reduce using rule 55 (EXP -> ID .)
    ELSE            reduce using rule 55 (EXP -> ID .)
    ,               reduce using rule 55 (EXP -> ID .)


state 47

    (56) EXP -> NUMBER .

    COMP_OP         reduce using rule 56 (EXP -> NUMBER .)
    +               reduce using rule 56 (EXP -> NUMBER .)
    -               reduce using rule 56 (EXP -> NUMBER .)
    *               reduce using rule 56 (EXP -> NUMBER .)
    /               reduce using rule 56 (EXP -> NUMBER .)
    END             reduce using rule 56 (EXP -> NUMBER .)
    ;               reduce using rule 56 (EXP -> NUMBER .)
    ELSE            reduce using rule 56 (EXP -> NUMBER .)
    )               reduce using rule 56 (EXP -> NUMBER .)
    LOGIC_OP_OR     reduce using rule 56 (EXP -> NUMBER .)
    LOGIC_OP_AND    reduce using rule 56 (EXP -> NUMBER .)
    ,               reduce using rule 56 (EXP -> NUMBER .)


state 48

    (57) EXP -> TRUE .

    COMP_OP         reduce using rule 57 (EXP -> TRUE .)
    +               reduce using rule 57 (EXP -> TRUE .)
    -               reduce using rule 57 (EXP -> TRUE .)
    *               reduce using rule 57 (EXP -> TRUE .)
    /               reduce using rule 57 (EXP -> TRUE .)
    END             reduce using rule 57 (EXP -> TRUE .)
    ;               reduce using rule 57 (EXP -> TRUE .)
    ELSE            reduce using rule 57 (EXP -> TRUE .)
    )               reduce using rule 57 (EXP -> TRUE .)
    LOGIC_OP_OR     reduce using rule 57 (EXP -> TRUE .)
    LOGIC_OP_AND    reduce using rule 57 (EXP -> TRUE .)
    ,               reduce using rule 57 (EXP -> TRUE .)


state 49

    (58) EXP -> FALSE .

    COMP_OP         reduce using rule 58 (EXP -> FALSE .)
    +               reduce using rule 58 (EXP -> FALSE .)
    -               reduce using rule 58 (EXP -> FALSE .)
    *               reduce using rule 58 (EXP -> FALSE .)
    /               reduce using rule 58 (EXP -> FALSE .)
    END             reduce using rule 58 (EXP -> FALSE .)
    ;               reduce using rule 58 (EXP -> FALSE .)
    ELSE            reduce using rule 58 (EXP -> FALSE .)
    )               reduce using rule 58 (EXP -> FALSE .)
    LOGIC_OP_OR     reduce using rule 58 (EXP -> FALSE .)
    LOGIC_OP_AND    reduce using rule 58 (EXP -> FALSE .)
    ,               reduce using rule 58 (EXP -> FALSE .)


state 50

    (39) COMMAND -> WHILE ( COM_EXP . ) DO COMMAND
    (48) COM_EXP -> COM_EXP . LOGIC_OP_OR COM_EXP
    (49) COM_EXP -> COM_EXP . LOGIC_OP_AND COM_EXP

    )               shift and go to state 79
    LOGIC_OP_OR     shift and go to state 72
    LOGIC_OP_AND    shift and go to state 73


state 51

    (55) EXP -> ID .
    (43) FUNCTION_CALL -> ID . ( PARAM_LIST )

    +               reduce using rule 55 (EXP -> ID .)
    -               reduce using rule 55 (EXP -> ID .)
    *               reduce using rule 55 (EXP -> ID .)
    /               reduce using rule 55 (EXP -> ID .)
    END             reduce using rule 55 (EXP -> ID .)
    ;               reduce using rule 55 (EXP -> ID .)
    ELSE            reduce using rule 55 (EXP -> ID .)
    (               shift and go to state 80


state 52

    (41) COMMAND -> ID ASSIGNMENT EXP .
    (50) EXP -> EXP . + EXP
    (51) EXP -> EXP . - EXP
    (52) EXP -> EXP . * EXP
    (53) EXP -> EXP . / EXP

    END             reduce using rule 41 (COMMAND -> ID ASSIGNMENT EXP .)
    ;               reduce using rule 41 (COMMAND -> ID ASSIGNMENT EXP .)
    ELSE            reduce using rule 41 (COMMAND -> ID ASSIGNMENT EXP .)
    +               shift and go to state 75
    -               shift and go to state 76
    *               shift and go to state 77
    /               shift and go to state 78


state 53

    (42) COMMAND -> ID ASSIGNMENT FUNCTION_CALL .

    END             reduce using rule 42 (COMMAND -> ID ASSIGNMENT FUNCTION_CALL .)
    ;               reduce using rule 42 (COMMAND -> ID ASSIGNMENT FUNCTION_CALL .)
    ELSE            reduce using rule 42 (COMMAND -> ID ASSIGNMENT FUNCTION_CALL .)


state 54

    (28) VARIABLE -> VAR ID_LIST : . DATA_TYPE ;
    (19) DATA_TYPE -> . INTEGER
    (20) DATA_TYPE -> . REAL
    (21) DATA_TYPE -> . CHAR
    (22) DATA_TYPE -> . BOOLEAN
    (23) DATA_TYPE -> . ARRAY [ NUMBER ] OF DATA_TYPE
    (24) DATA_TYPE -> . RECORD FIELDS END
    (25) DATA_TYPE -> . ID

    INTEGER         shift and go to state 58
    REAL            shift and go to state 59
    CHAR            shift and go to state 60
    BOOLEAN         shift and go to state 61
    ARRAY           shift and go to state 62
    RECORD          shift and go to state 63
    ID              shift and go to state 56

    DATA_TYPE                      shift and go to state 81

state 55

    (30) ID_LIST -> ID_LIST , . ID

    ID              shift and go to state 82


state 56

    (25) DATA_TYPE -> ID .

    ;               reduce using rule 25 (DATA_TYPE -> ID .)
    END             reduce using rule 25 (DATA_TYPE -> ID .)


state 57

    (18) TYPE_DECLARATION -> TYPE ID = DATA_TYPE . ;

    ;               shift and go to state 83


state 58

    (19) DATA_TYPE -> INTEGER .

    ;               reduce using rule 19 (DATA_TYPE -> INTEGER .)
    END             reduce using rule 19 (DATA_TYPE -> INTEGER .)


state 59

    (20) DATA_TYPE -> REAL .

    ;               reduce using rule 20 (DATA_TYPE -> REAL .)
    END             reduce using rule 20 (DATA_TYPE -> REAL .)


state 60

    (21) DATA_TYPE -> CHAR .

    ;               reduce using rule 21 (DATA_TYPE -> CHAR .)
    END             reduce using rule 21 (DATA_TYPE -> CHAR .)


state 61

    (22) DATA_TYPE -> BOOLEAN .

    ;               reduce using rule 22 (DATA_TYPE -> BOOLEAN .)
    END             reduce using rule 22 (DATA_TYPE -> BOOLEAN .)


state 62

    (23) DATA_TYPE -> ARRAY . [ NUMBER ] OF DATA_TYPE

    [               shift and go to state 84


state 63

    (24) DATA_TYPE -> RECORD . FIELDS END
    (31) FIELDS -> . FIELD FIELD_LIST
    (32) FIELD -> . ID : DATA_TYPE

    ID              shift and go to state 87

    FIELDS                         shift and go to state 85
    FIELD                          shift and go to state 86

state 64

    (7) CONSTANT -> CONST ID = CONST_VALUE ; .

    CONST           reduce using rule 7 (CONSTANT -> CONST ID = CONST_VALUE ; .)
    TYPE            reduce using rule 7 (CONSTANT -> CONST ID = CONST_VALUE ; .)
    VAR             reduce using rule 7 (CONSTANT -> CONST ID = CONST_VALUE ; .)
    BEGIN           reduce using rule 7 (CONSTANT -> CONST ID = CONST_VALUE ; .)


state 65

    (12) CONST_EXP -> CONST_EXP + . CONST_EXP
    (10) CONST_EXP -> . NUMBER
    (11) CONST_EXP -> . ( CONST_EXP )
    (12) CONST_EXP -> . CONST_EXP + CONST_EXP
    (13) CONST_EXP -> . CONST_EXP - CONST_EXP
    (14) CONST_EXP -> . CONST_EXP * CONST_EXP
    (15) CONST_EXP -> . CONST_EXP / CONST_EXP

    NUMBER          shift and go to state 39
    (               shift and go to state 40

    CONST_EXP                      shift and go to state 88

state 66

    (13) CONST_EXP -> CONST_EXP - . CONST_EXP
    (10) CONST_EXP -> . NUMBER
    (11) CONST_EXP -> . ( CONST_EXP )
    (12) CONST_EXP -> . CONST_EXP + CONST_EXP
    (13) CONST_EXP -> . CONST_EXP - CONST_EXP
    (14) CONST_EXP -> . CONST_EXP * CONST_EXP
    (15) CONST_EXP -> . CONST_EXP / CONST_EXP

    NUMBER          shift and go to state 39
    (               shift and go to state 40

    CONST_EXP                      shift and go to state 89

state 67

    (14) CONST_EXP -> CONST_EXP * . CONST_EXP
    (10) CONST_EXP -> . NUMBER
    (11) CONST_EXP -> . ( CONST_EXP )
    (12) CONST_EXP -> . CONST_EXP + CONST_EXP
    (13) CONST_EXP -> . CONST_EXP - CONST_EXP
    (14) CONST_EXP -> . CONST_EXP * CONST_EXP
    (15) CONST_EXP -> . CONST_EXP / CONST_EXP

    NUMBER          shift and go to state 39
    (               shift and go to state 40

    CONST_EXP                      shift and go to state 90

state 68

    (15) CONST_EXP -> CONST_EXP / . CONST_EXP
    (10) CONST_EXP -> . NUMBER
    (11) CONST_EXP -> . ( CONST_EXP )
    (12) CONST_EXP -> . CONST_EXP + CONST_EXP
    (13) CONST_EXP -> . CONST_EXP - CONST_EXP
    (14) CONST_EXP -> . CONST_EXP * CONST_EXP
    (15) CONST_EXP -> . CONST_EXP / CONST_EXP

    NUMBER          shift and go to state 39
    (               shift and go to state 40

    CONST_EXP                      shift and go to state 91

state 69

    (11) CONST_EXP -> ( CONST_EXP . )
    (12) CONST_EXP -> CONST_EXP . + CONST_EXP
    (13) CONST_EXP -> CONST_EXP . - CONST_EXP
    (14) CONST_EXP -> CONST_EXP . * CONST_EXP
    (15) CONST_EXP -> CONST_EXP . / CONST_EXP

    )               shift and go to state 92
    +               shift and go to state 65
    -               shift and go to state 66
    *               shift and go to state 67
    /               shift and go to state 68


state 70

    (54) EXP -> ( EXP . )
    (50) EXP -> EXP . + EXP
    (51) EXP -> EXP . - EXP
    (52) EXP -> EXP . * EXP
    (53) EXP -> EXP . / EXP

    )               shift and go to state 93
    +               shift and go to state 75
    -               shift and go to state 76
    *               shift and go to state 77
    /               shift and go to state 78


state 71

    (37) COMMAND -> IF ( COM_EXP ) . THEN COMMAND
    (38) COMMAND -> IF ( COM_EXP ) . THEN COMMAND ELSE COMMAND

    THEN            shift and go to state 94


state 72

    (48) COM_EXP -> COM_EXP LOGIC_OP_OR . COM_EXP
    (47) COM_EXP -> . EXP COMP_OP EXP
    (48) COM_EXP -> . COM_EXP LOGIC_OP_OR COM_EXP
    (49) COM_EXP -> . COM_EXP LOGIC_OP_AND COM_EXP
    (50) EXP -> . EXP + EXP
    (51) EXP -> . EXP - EXP
    (52) EXP -> . EXP * EXP
    (53) EXP -> . EXP / EXP
    (54) EXP -> . ( EXP )
    (55) EXP -> . ID
    (56) EXP -> . NUMBER
    (57) EXP -> . TRUE
    (58) EXP -> . FALSE

    (               shift and go to state 43
    ID              shift and go to state 46
    NUMBER          shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49

    COM_EXP                        shift and go to state 95
    EXP                            shift and go to state 45

state 73

    (49) COM_EXP -> COM_EXP LOGIC_OP_AND . COM_EXP
    (47) COM_EXP -> . EXP COMP_OP EXP
    (48) COM_EXP -> . COM_EXP LOGIC_OP_OR COM_EXP
    (49) COM_EXP -> . COM_EXP LOGIC_OP_AND COM_EXP
    (50) EXP -> . EXP + EXP
    (51) EXP -> . EXP - EXP
    (52) EXP -> . EXP * EXP
    (53) EXP -> . EXP / EXP
    (54) EXP -> . ( EXP )
    (55) EXP -> . ID
    (56) EXP -> . NUMBER
    (57) EXP -> . TRUE
    (58) EXP -> . FALSE

    (               shift and go to state 43
    ID              shift and go to state 46
    NUMBER          shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49

    COM_EXP                        shift and go to state 96
    EXP                            shift and go to state 45

state 74

    (47) COM_EXP -> EXP COMP_OP . EXP
    (50) EXP -> . EXP + EXP
    (51) EXP -> . EXP - EXP
    (52) EXP -> . EXP * EXP
    (53) EXP -> . EXP / EXP
    (54) EXP -> . ( EXP )
    (55) EXP -> . ID
    (56) EXP -> . NUMBER
    (57) EXP -> . TRUE
    (58) EXP -> . FALSE

    (               shift and go to state 43
    ID              shift and go to state 46
    NUMBER          shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49

    EXP                            shift and go to state 97

state 75

    (50) EXP -> EXP + . EXP
    (50) EXP -> . EXP + EXP
    (51) EXP -> . EXP - EXP
    (52) EXP -> . EXP * EXP
    (53) EXP -> . EXP / EXP
    (54) EXP -> . ( EXP )
    (55) EXP -> . ID
    (56) EXP -> . NUMBER
    (57) EXP -> . TRUE
    (58) EXP -> . FALSE

    (               shift and go to state 43
    ID              shift and go to state 46
    NUMBER          shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49

    EXP                            shift and go to state 98

state 76

    (51) EXP -> EXP - . EXP
    (50) EXP -> . EXP + EXP
    (51) EXP -> . EXP - EXP
    (52) EXP -> . EXP * EXP
    (53) EXP -> . EXP / EXP
    (54) EXP -> . ( EXP )
    (55) EXP -> . ID
    (56) EXP -> . NUMBER
    (57) EXP -> . TRUE
    (58) EXP -> . FALSE

    (               shift and go to state 43
    ID              shift and go to state 46
    NUMBER          shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49

    EXP                            shift and go to state 99

state 77

    (52) EXP -> EXP * . EXP
    (50) EXP -> . EXP + EXP
    (51) EXP -> . EXP - EXP
    (52) EXP -> . EXP * EXP
    (53) EXP -> . EXP / EXP
    (54) EXP -> . ( EXP )
    (55) EXP -> . ID
    (56) EXP -> . NUMBER
    (57) EXP -> . TRUE
    (58) EXP -> . FALSE

    (               shift and go to state 43
    ID              shift and go to state 46
    NUMBER          shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49

    EXP                            shift and go to state 100

state 78

    (53) EXP -> EXP / . EXP
    (50) EXP -> . EXP + EXP
    (51) EXP -> . EXP - EXP
    (52) EXP -> . EXP * EXP
    (53) EXP -> . EXP / EXP
    (54) EXP -> . ( EXP )
    (55) EXP -> . ID
    (56) EXP -> . NUMBER
    (57) EXP -> . TRUE
    (58) EXP -> . FALSE

    (               shift and go to state 43
    ID              shift and go to state 46
    NUMBER          shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49

    EXP                            shift and go to state 101

state 79

    (39) COMMAND -> WHILE ( COM_EXP ) . DO COMMAND

    DO              shift and go to state 102


state 80

    (43) FUNCTION_CALL -> ID ( . PARAM_LIST )
    (44) PARAM_LIST -> . EXP
    (45) PARAM_LIST -> . PARAM_LIST , EXP
    (46) PARAM_LIST -> .
    (50) EXP -> . EXP + EXP
    (51) EXP -> . EXP - EXP
    (52) EXP -> . EXP * EXP
    (53) EXP -> . EXP / EXP
    (54) EXP -> . ( EXP )
    (55) EXP -> . ID
    (56) EXP -> . NUMBER
    (57) EXP -> . TRUE
    (58) EXP -> . FALSE

    )               reduce using rule 46 (PARAM_LIST -> .)
    ,               reduce using rule 46 (PARAM_LIST -> .)
    (               shift and go to state 43
    ID              shift and go to state 46
    NUMBER          shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49

    PARAM_LIST                     shift and go to state 103
    EXP                            shift and go to state 104

state 81

    (28) VARIABLE -> VAR ID_LIST : DATA_TYPE . ;

    ;               shift and go to state 105


state 82

    (30) ID_LIST -> ID_LIST , ID .

    :               reduce using rule 30 (ID_LIST -> ID_LIST , ID .)
    ,               reduce using rule 30 (ID_LIST -> ID_LIST , ID .)


state 83

    (18) TYPE_DECLARATION -> TYPE ID = DATA_TYPE ; .

    TYPE            reduce using rule 18 (TYPE_DECLARATION -> TYPE ID = DATA_TYPE ; .)
    VAR             reduce using rule 18 (TYPE_DECLARATION -> TYPE ID = DATA_TYPE ; .)
    BEGIN           reduce using rule 18 (TYPE_DECLARATION -> TYPE ID = DATA_TYPE ; .)


state 84

    (23) DATA_TYPE -> ARRAY [ . NUMBER ] OF DATA_TYPE

    NUMBER          shift and go to state 106


state 85

    (24) DATA_TYPE -> RECORD FIELDS . END

    END             shift and go to state 107


state 86

    (31) FIELDS -> FIELD . FIELD_LIST
    (33) FIELD_LIST -> . ; FIELD FIELD_LIST
    (34) FIELD_LIST -> .

    ;               shift and go to state 109
    END             reduce using rule 34 (FIELD_LIST -> .)

    FIELD_LIST                     shift and go to state 108

state 87

    (32) FIELD -> ID . : DATA_TYPE

    :               shift and go to state 110


state 88

    (12) CONST_EXP -> CONST_EXP + CONST_EXP .
    (12) CONST_EXP -> CONST_EXP . + CONST_EXP
    (13) CONST_EXP -> CONST_EXP . - CONST_EXP
    (14) CONST_EXP -> CONST_EXP . * CONST_EXP
    (15) CONST_EXP -> CONST_EXP . / CONST_EXP

    +               reduce using rule 12 (CONST_EXP -> CONST_EXP + CONST_EXP .)
    -               reduce using rule 12 (CONST_EXP -> CONST_EXP + CONST_EXP .)
    ;               reduce using rule 12 (CONST_EXP -> CONST_EXP + CONST_EXP .)
    )               reduce using rule 12 (CONST_EXP -> CONST_EXP + CONST_EXP .)
    *               shift and go to state 67
    /               shift and go to state 68

  ! *               [ reduce using rule 12 (CONST_EXP -> CONST_EXP + CONST_EXP .) ]
  ! /               [ reduce using rule 12 (CONST_EXP -> CONST_EXP + CONST_EXP .) ]
  ! +               [ shift and go to state 65 ]
  ! -               [ shift and go to state 66 ]


state 89

    (13) CONST_EXP -> CONST_EXP - CONST_EXP .
    (12) CONST_EXP -> CONST_EXP . + CONST_EXP
    (13) CONST_EXP -> CONST_EXP . - CONST_EXP
    (14) CONST_EXP -> CONST_EXP . * CONST_EXP
    (15) CONST_EXP -> CONST_EXP . / CONST_EXP

    +               reduce using rule 13 (CONST_EXP -> CONST_EXP - CONST_EXP .)
    -               reduce using rule 13 (CONST_EXP -> CONST_EXP - CONST_EXP .)
    ;               reduce using rule 13 (CONST_EXP -> CONST_EXP - CONST_EXP .)
    )               reduce using rule 13 (CONST_EXP -> CONST_EXP - CONST_EXP .)
    *               shift and go to state 67
    /               shift and go to state 68

  ! *               [ reduce using rule 13 (CONST_EXP -> CONST_EXP - CONST_EXP .) ]
  ! /               [ reduce using rule 13 (CONST_EXP -> CONST_EXP - CONST_EXP .) ]
  ! +               [ shift and go to state 65 ]
  ! -               [ shift and go to state 66 ]


state 90

    (14) CONST_EXP -> CONST_EXP * CONST_EXP .
    (12) CONST_EXP -> CONST_EXP . + CONST_EXP
    (13) CONST_EXP -> CONST_EXP . - CONST_EXP
    (14) CONST_EXP -> CONST_EXP . * CONST_EXP
    (15) CONST_EXP -> CONST_EXP . / CONST_EXP

    +               reduce using rule 14 (CONST_EXP -> CONST_EXP * CONST_EXP .)
    -               reduce using rule 14 (CONST_EXP -> CONST_EXP * CONST_EXP .)
    *               reduce using rule 14 (CONST_EXP -> CONST_EXP * CONST_EXP .)
    /               reduce using rule 14 (CONST_EXP -> CONST_EXP * CONST_EXP .)
    ;               reduce using rule 14 (CONST_EXP -> CONST_EXP * CONST_EXP .)
    )               reduce using rule 14 (CONST_EXP -> CONST_EXP * CONST_EXP .)

  ! +               [ shift and go to state 65 ]
  ! -               [ shift and go to state 66 ]
  ! *               [ shift and go to state 67 ]
  ! /               [ shift and go to state 68 ]


state 91

    (15) CONST_EXP -> CONST_EXP / CONST_EXP .
    (12) CONST_EXP -> CONST_EXP . + CONST_EXP
    (13) CONST_EXP -> CONST_EXP . - CONST_EXP
    (14) CONST_EXP -> CONST_EXP . * CONST_EXP
    (15) CONST_EXP -> CONST_EXP . / CONST_EXP

    +               reduce using rule 15 (CONST_EXP -> CONST_EXP / CONST_EXP .)
    -               reduce using rule 15 (CONST_EXP -> CONST_EXP / CONST_EXP .)
    *               reduce using rule 15 (CONST_EXP -> CONST_EXP / CONST_EXP .)
    /               reduce using rule 15 (CONST_EXP -> CONST_EXP / CONST_EXP .)
    ;               reduce using rule 15 (CONST_EXP -> CONST_EXP / CONST_EXP .)
    )               reduce using rule 15 (CONST_EXP -> CONST_EXP / CONST_EXP .)

  ! +               [ shift and go to state 65 ]
  ! -               [ shift and go to state 66 ]
  ! *               [ shift and go to state 67 ]
  ! /               [ shift and go to state 68 ]


state 92

    (11) CONST_EXP -> ( CONST_EXP ) .

    +               reduce using rule 11 (CONST_EXP -> ( CONST_EXP ) .)
    -               reduce using rule 11 (CONST_EXP -> ( CONST_EXP ) .)
    *               reduce using rule 11 (CONST_EXP -> ( CONST_EXP ) .)
    /               reduce using rule 11 (CONST_EXP -> ( CONST_EXP ) .)
    ;               reduce using rule 11 (CONST_EXP -> ( CONST_EXP ) .)
    )               reduce using rule 11 (CONST_EXP -> ( CONST_EXP ) .)


state 93

    (54) EXP -> ( EXP ) .

    COMP_OP         reduce using rule 54 (EXP -> ( EXP ) .)
    +               reduce using rule 54 (EXP -> ( EXP ) .)
    -               reduce using rule 54 (EXP -> ( EXP ) .)
    *               reduce using rule 54 (EXP -> ( EXP ) .)
    /               reduce using rule 54 (EXP -> ( EXP ) .)
    END             reduce using rule 54 (EXP -> ( EXP ) .)
    ;               reduce using rule 54 (EXP -> ( EXP ) .)
    ELSE            reduce using rule 54 (EXP -> ( EXP ) .)
    )               reduce using rule 54 (EXP -> ( EXP ) .)
    LOGIC_OP_OR     reduce using rule 54 (EXP -> ( EXP ) .)
    LOGIC_OP_AND    reduce using rule 54 (EXP -> ( EXP ) .)
    ,               reduce using rule 54 (EXP -> ( EXP ) .)


state 94

    (37) COMMAND -> IF ( COM_EXP ) THEN . COMMAND
    (38) COMMAND -> IF ( COM_EXP ) THEN . COMMAND ELSE COMMAND
    (37) COMMAND -> . IF ( COM_EXP ) THEN COMMAND
    (38) COMMAND -> . IF ( COM_EXP ) THEN COMMAND ELSE COMMAND
    (39) COMMAND -> . WHILE ( COM_EXP ) DO COMMAND
    (40) COMMAND -> . BEGIN COMMAND_LIST END
    (41) COMMAND -> . ID ASSIGNMENT EXP
    (42) COMMAND -> . ID ASSIGNMENT FUNCTION_CALL

    IF              shift and go to state 17
    WHILE           shift and go to state 18
    BEGIN           shift and go to state 13
    ID              shift and go to state 19

    COMMAND                        shift and go to state 111

state 95

    (48) COM_EXP -> COM_EXP LOGIC_OP_OR COM_EXP .
    (48) COM_EXP -> COM_EXP . LOGIC_OP_OR COM_EXP
    (49) COM_EXP -> COM_EXP . LOGIC_OP_AND COM_EXP

    )               reduce using rule 48 (COM_EXP -> COM_EXP LOGIC_OP_OR COM_EXP .)
    LOGIC_OP_OR     reduce using rule 48 (COM_EXP -> COM_EXP LOGIC_OP_OR COM_EXP .)
    LOGIC_OP_AND    shift and go to state 73

  ! LOGIC_OP_AND    [ reduce using rule 48 (COM_EXP -> COM_EXP LOGIC_OP_OR COM_EXP .) ]
  ! LOGIC_OP_OR     [ shift and go to state 72 ]


state 96

    (49) COM_EXP -> COM_EXP LOGIC_OP_AND COM_EXP .
    (48) COM_EXP -> COM_EXP . LOGIC_OP_OR COM_EXP
    (49) COM_EXP -> COM_EXP . LOGIC_OP_AND COM_EXP

    )               reduce using rule 49 (COM_EXP -> COM_EXP LOGIC_OP_AND COM_EXP .)
    LOGIC_OP_OR     reduce using rule 49 (COM_EXP -> COM_EXP LOGIC_OP_AND COM_EXP .)
    LOGIC_OP_AND    reduce using rule 49 (COM_EXP -> COM_EXP LOGIC_OP_AND COM_EXP .)

  ! LOGIC_OP_OR     [ shift and go to state 72 ]
  ! LOGIC_OP_AND    [ shift and go to state 73 ]


state 97

    (47) COM_EXP -> EXP COMP_OP EXP .
    (50) EXP -> EXP . + EXP
    (51) EXP -> EXP . - EXP
    (52) EXP -> EXP . * EXP
    (53) EXP -> EXP . / EXP

    )               reduce using rule 47 (COM_EXP -> EXP COMP_OP EXP .)
    LOGIC_OP_OR     reduce using rule 47 (COM_EXP -> EXP COMP_OP EXP .)
    LOGIC_OP_AND    reduce using rule 47 (COM_EXP -> EXP COMP_OP EXP .)
    +               shift and go to state 75
    -               shift and go to state 76
    *               shift and go to state 77
    /               shift and go to state 78


state 98

    (50) EXP -> EXP + EXP .
    (50) EXP -> EXP . + EXP
    (51) EXP -> EXP . - EXP
    (52) EXP -> EXP . * EXP
    (53) EXP -> EXP . / EXP

    COMP_OP         reduce using rule 50 (EXP -> EXP + EXP .)
    +               reduce using rule 50 (EXP -> EXP + EXP .)
    -               reduce using rule 50 (EXP -> EXP + EXP .)
    END             reduce using rule 50 (EXP -> EXP + EXP .)
    ;               reduce using rule 50 (EXP -> EXP + EXP .)
    ELSE            reduce using rule 50 (EXP -> EXP + EXP .)
    )               reduce using rule 50 (EXP -> EXP + EXP .)
    LOGIC_OP_OR     reduce using rule 50 (EXP -> EXP + EXP .)
    LOGIC_OP_AND    reduce using rule 50 (EXP -> EXP + EXP .)
    ,               reduce using rule 50 (EXP -> EXP + EXP .)
    *               shift and go to state 77
    /               shift and go to state 78

  ! *               [ reduce using rule 50 (EXP -> EXP + EXP .) ]
  ! /               [ reduce using rule 50 (EXP -> EXP + EXP .) ]
  ! +               [ shift and go to state 75 ]
  ! -               [ shift and go to state 76 ]


state 99

    (51) EXP -> EXP - EXP .
    (50) EXP -> EXP . + EXP
    (51) EXP -> EXP . - EXP
    (52) EXP -> EXP . * EXP
    (53) EXP -> EXP . / EXP

    COMP_OP         reduce using rule 51 (EXP -> EXP - EXP .)
    +               reduce using rule 51 (EXP -> EXP - EXP .)
    -               reduce using rule 51 (EXP -> EXP - EXP .)
    END             reduce using rule 51 (EXP -> EXP - EXP .)
    ;               reduce using rule 51 (EXP -> EXP - EXP .)
    ELSE            reduce using rule 51 (EXP -> EXP - EXP .)
    )               reduce using rule 51 (EXP -> EXP - EXP .)
    LOGIC_OP_OR     reduce using rule 51 (EXP -> EXP - EXP .)
    LOGIC_OP_AND    reduce using rule 51 (EXP -> EXP - EXP .)
    ,               reduce using rule 51 (EXP -> EXP - EXP .)
    *               shift and go to state 77
    /               shift and go to state 78

  ! *               [ reduce using rule 51 (EXP -> EXP - EXP .) ]
  ! /               [ reduce using rule 51 (EXP -> EXP - EXP .) ]
  ! +               [ shift and go to state 75 ]
  ! -               [ shift and go to state 76 ]


state 100

    (52) EXP -> EXP * EXP .
    (50) EXP -> EXP . + EXP
    (51) EXP -> EXP . - EXP
    (52) EXP -> EXP . * EXP
    (53) EXP -> EXP . / EXP

    COMP_OP         reduce using rule 52 (EXP -> EXP * EXP .)
    +               reduce using rule 52 (EXP -> EXP * EXP .)
    -               reduce using rule 52 (EXP -> EXP * EXP .)
    *               reduce using rule 52 (EXP -> EXP * EXP .)
    /               reduce using rule 52 (EXP -> EXP * EXP .)
    END             reduce using rule 52 (EXP -> EXP * EXP .)
    ;               reduce using rule 52 (EXP -> EXP * EXP .)
    ELSE            reduce using rule 52 (EXP -> EXP * EXP .)
    )               reduce using rule 52 (EXP -> EXP * EXP .)
    LOGIC_OP_OR     reduce using rule 52 (EXP -> EXP * EXP .)
    LOGIC_OP_AND    reduce using rule 52 (EXP -> EXP * EXP .)
    ,               reduce using rule 52 (EXP -> EXP * EXP .)

  ! +               [ shift and go to state 75 ]
  ! -               [ shift and go to state 76 ]
  ! *               [ shift and go to state 77 ]
  ! /               [ shift and go to state 78 ]


state 101

    (53) EXP -> EXP / EXP .
    (50) EXP -> EXP . + EXP
    (51) EXP -> EXP . - EXP
    (52) EXP -> EXP . * EXP
    (53) EXP -> EXP . / EXP

    COMP_OP         reduce using rule 53 (EXP -> EXP / EXP .)
    +               reduce using rule 53 (EXP -> EXP / EXP .)
    -               reduce using rule 53 (EXP -> EXP / EXP .)
    *               reduce using rule 53 (EXP -> EXP / EXP .)
    /               reduce using rule 53 (EXP -> EXP / EXP .)
    END             reduce using rule 53 (EXP -> EXP / EXP .)
    ;               reduce using rule 53 (EXP -> EXP / EXP .)
    ELSE            reduce using rule 53 (EXP -> EXP / EXP .)
    )               reduce using rule 53 (EXP -> EXP / EXP .)
    LOGIC_OP_OR     reduce using rule 53 (EXP -> EXP / EXP .)
    LOGIC_OP_AND    reduce using rule 53 (EXP -> EXP / EXP .)
    ,               reduce using rule 53 (EXP -> EXP / EXP .)

  ! +               [ shift and go to state 75 ]
  ! -               [ shift and go to state 76 ]
  ! *               [ shift and go to state 77 ]
  ! /               [ shift and go to state 78 ]


state 102

    (39) COMMAND -> WHILE ( COM_EXP ) DO . COMMAND
    (37) COMMAND -> . IF ( COM_EXP ) THEN COMMAND
    (38) COMMAND -> . IF ( COM_EXP ) THEN COMMAND ELSE COMMAND
    (39) COMMAND -> . WHILE ( COM_EXP ) DO COMMAND
    (40) COMMAND -> . BEGIN COMMAND_LIST END
    (41) COMMAND -> . ID ASSIGNMENT EXP
    (42) COMMAND -> . ID ASSIGNMENT FUNCTION_CALL

    IF              shift and go to state 17
    WHILE           shift and go to state 18
    BEGIN           shift and go to state 13
    ID              shift and go to state 19

    COMMAND                        shift and go to state 112

state 103

    (43) FUNCTION_CALL -> ID ( PARAM_LIST . )
    (45) PARAM_LIST -> PARAM_LIST . , EXP

    )               shift and go to state 113
    ,               shift and go to state 114


state 104

    (44) PARAM_LIST -> EXP .
    (50) EXP -> EXP . + EXP
    (51) EXP -> EXP . - EXP
    (52) EXP -> EXP . * EXP
    (53) EXP -> EXP . / EXP

    )               reduce using rule 44 (PARAM_LIST -> EXP .)
    ,               reduce using rule 44 (PARAM_LIST -> EXP .)
    +               shift and go to state 75
    -               shift and go to state 76
    *               shift and go to state 77
    /               shift and go to state 78


state 105

    (28) VARIABLE -> VAR ID_LIST : DATA_TYPE ; .

    VAR             reduce using rule 28 (VARIABLE -> VAR ID_LIST : DATA_TYPE ; .)
    BEGIN           reduce using rule 28 (VARIABLE -> VAR ID_LIST : DATA_TYPE ; .)


state 106

    (23) DATA_TYPE -> ARRAY [ NUMBER . ] OF DATA_TYPE

    ]               shift and go to state 115


state 107

    (24) DATA_TYPE -> RECORD FIELDS END .

    ;               reduce using rule 24 (DATA_TYPE -> RECORD FIELDS END .)
    END             reduce using rule 24 (DATA_TYPE -> RECORD FIELDS END .)


state 108

    (31) FIELDS -> FIELD FIELD_LIST .

    END             reduce using rule 31 (FIELDS -> FIELD FIELD_LIST .)


state 109

    (33) FIELD_LIST -> ; . FIELD FIELD_LIST
    (32) FIELD -> . ID : DATA_TYPE

    ID              shift and go to state 87

    FIELD                          shift and go to state 116

state 110

    (32) FIELD -> ID : . DATA_TYPE
    (19) DATA_TYPE -> . INTEGER
    (20) DATA_TYPE -> . REAL
    (21) DATA_TYPE -> . CHAR
    (22) DATA_TYPE -> . BOOLEAN
    (23) DATA_TYPE -> . ARRAY [ NUMBER ] OF DATA_TYPE
    (24) DATA_TYPE -> . RECORD FIELDS END
    (25) DATA_TYPE -> . ID

    INTEGER         shift and go to state 58
    REAL            shift and go to state 59
    CHAR            shift and go to state 60
    BOOLEAN         shift and go to state 61
    ARRAY           shift and go to state 62
    RECORD          shift and go to state 63
    ID              shift and go to state 56

    DATA_TYPE                      shift and go to state 117

state 111

    (37) COMMAND -> IF ( COM_EXP ) THEN COMMAND .
    (38) COMMAND -> IF ( COM_EXP ) THEN COMMAND . ELSE COMMAND

    END             reduce using rule 37 (COMMAND -> IF ( COM_EXP ) THEN COMMAND .)
    ;               reduce using rule 37 (COMMAND -> IF ( COM_EXP ) THEN COMMAND .)
    ELSE            shift and go to state 118

  ! ELSE            [ reduce using rule 37 (COMMAND -> IF ( COM_EXP ) THEN COMMAND .) ]


state 112

    (39) COMMAND -> WHILE ( COM_EXP ) DO COMMAND .

    END             reduce using rule 39 (COMMAND -> WHILE ( COM_EXP ) DO COMMAND .)
    ;               reduce using rule 39 (COMMAND -> WHILE ( COM_EXP ) DO COMMAND .)
    ELSE            reduce using rule 39 (COMMAND -> WHILE ( COM_EXP ) DO COMMAND .)


state 113

    (43) FUNCTION_CALL -> ID ( PARAM_LIST ) .

    END             reduce using rule 43 (FUNCTION_CALL -> ID ( PARAM_LIST ) .)
    ;               reduce using rule 43 (FUNCTION_CALL -> ID ( PARAM_LIST ) .)
    ELSE            reduce using rule 43 (FUNCTION_CALL -> ID ( PARAM_LIST ) .)


state 114

    (45) PARAM_LIST -> PARAM_LIST , . EXP
    (50) EXP -> . EXP + EXP
    (51) EXP -> . EXP - EXP
    (52) EXP -> . EXP * EXP
    (53) EXP -> . EXP / EXP
    (54) EXP -> . ( EXP )
    (55) EXP -> . ID
    (56) EXP -> . NUMBER
    (57) EXP -> . TRUE
    (58) EXP -> . FALSE

    (               shift and go to state 43
    ID              shift and go to state 46
    NUMBER          shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49

    EXP                            shift and go to state 119

state 115

    (23) DATA_TYPE -> ARRAY [ NUMBER ] . OF DATA_TYPE

    OF              shift and go to state 120


state 116

    (33) FIELD_LIST -> ; FIELD . FIELD_LIST
    (33) FIELD_LIST -> . ; FIELD FIELD_LIST
    (34) FIELD_LIST -> .

    ;               shift and go to state 109
    END             reduce using rule 34 (FIELD_LIST -> .)

    FIELD_LIST                     shift and go to state 121

state 117

    (32) FIELD -> ID : DATA_TYPE .

    ;               reduce using rule 32 (FIELD -> ID : DATA_TYPE .)
    END             reduce using rule 32 (FIELD -> ID : DATA_TYPE .)


state 118

    (38) COMMAND -> IF ( COM_EXP ) THEN COMMAND ELSE . COMMAND
    (37) COMMAND -> . IF ( COM_EXP ) THEN COMMAND
    (38) COMMAND -> . IF ( COM_EXP ) THEN COMMAND ELSE COMMAND
    (39) COMMAND -> . WHILE ( COM_EXP ) DO COMMAND
    (40) COMMAND -> . BEGIN COMMAND_LIST END
    (41) COMMAND -> . ID ASSIGNMENT EXP
    (42) COMMAND -> . ID ASSIGNMENT FUNCTION_CALL

    IF              shift and go to state 17
    WHILE           shift and go to state 18
    BEGIN           shift and go to state 13
    ID              shift and go to state 19

    COMMAND                        shift and go to state 122

state 119

    (45) PARAM_LIST -> PARAM_LIST , EXP .
    (50) EXP -> EXP . + EXP
    (51) EXP -> EXP . - EXP
    (52) EXP -> EXP . * EXP
    (53) EXP -> EXP . / EXP

    )               reduce using rule 45 (PARAM_LIST -> PARAM_LIST , EXP .)
    ,               reduce using rule 45 (PARAM_LIST -> PARAM_LIST , EXP .)
    +               shift and go to state 75
    -               shift and go to state 76
    *               shift and go to state 77
    /               shift and go to state 78


state 120

    (23) DATA_TYPE -> ARRAY [ NUMBER ] OF . DATA_TYPE
    (19) DATA_TYPE -> . INTEGER
    (20) DATA_TYPE -> . REAL
    (21) DATA_TYPE -> . CHAR
    (22) DATA_TYPE -> . BOOLEAN
    (23) DATA_TYPE -> . ARRAY [ NUMBER ] OF DATA_TYPE
    (24) DATA_TYPE -> . RECORD FIELDS END
    (25) DATA_TYPE -> . ID

    INTEGER         shift and go to state 58
    REAL            shift and go to state 59
    CHAR            shift and go to state 60
    BOOLEAN         shift and go to state 61
    ARRAY           shift and go to state 62
    RECORD          shift and go to state 63
    ID              shift and go to state 56

    DATA_TYPE                      shift and go to state 123

state 121

    (33) FIELD_LIST -> ; FIELD FIELD_LIST .

    END             reduce using rule 33 (FIELD_LIST -> ; FIELD FIELD_LIST .)


state 122

    (38) COMMAND -> IF ( COM_EXP ) THEN COMMAND ELSE COMMAND .

    END             reduce using rule 38 (COMMAND -> IF ( COM_EXP ) THEN COMMAND ELSE COMMAND .)
    ;               reduce using rule 38 (COMMAND -> IF ( COM_EXP ) THEN COMMAND ELSE COMMAND .)
    ELSE            reduce using rule 38 (COMMAND -> IF ( COM_EXP ) THEN COMMAND ELSE COMMAND .)


state 123

    (23) DATA_TYPE -> ARRAY [ NUMBER ] OF DATA_TYPE .

    ;               reduce using rule 23 (DATA_TYPE -> ARRAY [ NUMBER ] OF DATA_TYPE .)
    END             reduce using rule 23 (DATA_TYPE -> ARRAY [ NUMBER ] OF DATA_TYPE .)

